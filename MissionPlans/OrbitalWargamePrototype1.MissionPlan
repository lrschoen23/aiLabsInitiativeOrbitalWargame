<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<FreeFlyerProjectFile xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" timePrecisionMode="nanosecond" schemaVersion="7.8.0.1">
  <ProjectInformation>
    <Author />
    <Source />
    <FreeFlyerVersion>7.8.1.50021</FreeFlyerVersion>
    <RevisionNumber />
    <Title />
    <Subject />
    <Category />
    <Keywords />
    <Comments />
    <Notes />
  </ProjectInformation>
  <ProjectPreferences>
    <General>
      <LockProjectFromEditing>false</LockProjectFromEditing>
    </General>
    <OnOpen>
      <ShowControlSequence>true</ShowControlSequence>
      <ShowEmptyEnvironment>false</ShowEmptyEnvironment>
      <ShowNotes>false</ShowNotes>
      <ShowHome>false</ShowHome>
      <ShowOutput>false</ShowOutput>
      <CreateBackup>false</CreateBackup>
      <BackupLocation></BackupLocation>
    </OnOpen>
    <OnRun>
      <SaveMissionPlan>false</SaveMissionPlan>
      <HideWarningMessages>false</HideWarningMessages>
    </OnRun>
  </ProjectPreferences>
  <ProjectDataFiles>
    <EarthOrientationFile useDefault="true"></EarthOrientationFile>
    <ElectronDensityCoefficientFile useDefault="true"></ElectronDensityCoefficientFile>
    <GeopotentialFile useDefault="true"></GeopotentialFile>
    <HarrisPriesterDragFile useDefault="true"></HarrisPriesterDragFile>
    <JacchiaAtmosphereModelFile useDefault="true"></JacchiaAtmosphereModelFile>
    <LeapSecondFile useDefault="true"></LeapSecondFile>
    <MagneticFieldFile useDefault="true"></MagneticFieldFile>
    <PlanetaryFile useDefault="true"></PlanetaryFile>
    <StationGeodeticsFile useDefault="true"></StationGeodeticsFile>
    <SolidTideFile useDefault="true"></SolidTideFile>
    <DSTFile useDefault="true"></DSTFile>
    <StarFieldFile useDefault="true"></StarFieldFile>
  </ProjectDataFiles>
  <ProjectObjects>
    <Object>
      <SolarSystem name="FF_SolarSystem" isConstant="false" isGlobal="true">
        <Name>FF_SolarSystem</Name>
        <ComputePolarMotion>true</ComputePolarMotion>
        <ApplyUT1Correction>true</ApplyUT1Correction>
        <COUpdateInterval units="s" displayed_units="s">0</COUpdateInterval>
        <NPUpdateInterval units="s" displayed_units="s">1800</NPUpdateInterval>
        <IonosphereOptions>
          <IonosphereOptions name="FF_SolarSystem_|ionoOptions|" isConstant="false" isGlobal="true">
            <Name>FF_SolarSystem_|ionoOptions|</Name>
            <MaximumHeight units="km" displayed_units="km">1000</MaximumHeight>
            <MinimumHeight units="km" displayed_units="km">80</MinimumHeight>
            <IntegrationStepSize units="km" displayed_units="km">25</IntegrationStepSize>
            <ScaleFactor units="" displayed_units="">1</ScaleFactor>
            <Model>0</Model>
            <metadata dim="0" />
          </IonosphereOptions>
        </IonosphereOptions>
        <NoradKeplerEqTolerance units="" displayed_units="">1e-12</NoradKeplerEqTolerance>
        <metadata dim="0" />
      </SolarSystem>
    </Object>
    <Object>
      <ConsoleWindow name="Console" isConstant="false" isGlobal="true">
        <Name>Console</Name>
        <WindowTitle>Console</WindowTitle>
        <WordWrap>false</WordWrap>
        <CurrentTextColor>0</CurrentTextColor>
        <BackColor>16777215</BackColor>
        <Dimension units="" displayed_units="">10</Dimension>
        <DockMode>1</DockMode>
        <CurrentFontType>0</CurrentFontType>
        <UseStdOut>false</UseStdOut>
        <ShowOnRun>false</ShowOnRun>
        <metadata dim="0" />
      </ConsoleWindow>
    </Object>
  </ProjectObjects>
  <ProjectMissionSequence>
    <ProjectExternals>
      <ProjectExternal included="true" autosave="true" contentType="FreeFlyerScript">.\PlotUtilities.FFProcedure</ProjectExternal>
    </ProjectExternals>
    <ProjectCommands>
      <FreeForm enabled="true">
        <Label>Initialize</Label>
        <Bookmarks />
        <Breakpoints />
        <FreeFormScript><![CDATA[
Global TimeSpan simStepSize = TimeSpan.FromSeconds(300);

Global TimeSpan aheadPredictTime = TimeSpan.FromHours(18);
Global TimeSpan aheadPredictUpdateInterval = TimeSpan.FromSeconds(300);
Global Constant Variable aheadPredictRangeUpdateLimit = 300;

Global TimeSpan simStartEpoch = TimeTools.ParseCalendarDate("Jun 09 2025 15:00:00.000", "TAI", "TAI", "MJD GSFC");

Global Variable colorRed1 = ColorTools.InterpolateColorHSV({ColorTools.White, ColorTools.Red, ColorTools.Black}, 0.5);
Global Variable colorRed2 = ColorTools.InterpolateColorHSV({ColorTools.White, ColorTools.Red, ColorTools.Black}, 0.75);
Global Variable colorRed3 = ColorTools.InterpolateColorHSV({ColorTools.White, ColorTools.Red, ColorTools.Black}, 0.25);
Global Variable colorRed4 = ColorTools.InterpolateColorHSV({ColorTools.White, ColorTools.Red, ColorTools.Black}, 0.1);
Global Variable colorBlue1 = ColorTools.DodgerBlue;

Global Variable radialViewTailLength = 3e2 * 300 / simStepSize.ToSeconds();

Global Variable doOptimizationAndSaveValues = 0;

Formation red;
Formation blue;

red.Count = 3;
blue.Count = 1;

red.ViewAsGroup = 0;
blue.ViewAsGroup = 0;

Global Array sensativePayloadUnitVectorBCS = {0, 0, 1};


Global GraphicsOverlay overlayRed1Future;
overlayRed1Future.SetReferenceObject(blue[0].ObjectId);
overlayRed1Future.DefaultColor = ColorTools.LightGray;

Global GraphicsOverlay overlayRed2Future;
overlayRed2Future.SetReferenceObject(blue[0].ObjectId);
overlayRed2Future.DefaultColor = ColorTools.LightGray;

Global GraphicsOverlay overlayRed3Future;
overlayRed3Future.SetReferenceObject(blue[0].ObjectId);
overlayRed3Future.DefaultColor = ColorTools.LightGray;


Global ViewWindow radialView;
radialView.CurrentViewpoint.ThreeDView.Radius = 2147.54485002776;
radialView.CurrentViewpoint.ThreeDView.RightAscension = 270;
radialView.CurrentViewpoint.ThreeDView.Declination = 0;
radialView.AddObject(red);
radialView.AddObject(blue);
radialView.AddObject(overlayRed1Future);
radialView.AddObject(overlayRed2Future);
radialView.AddObject(overlayRed3Future);
radialView.CurrentViewpoint.ThreeDView.Source = blue[0].ObjectId;
radialView.CurrentViewpoint.ThreeDView.Target = blue[0].ObjectId;
radialView.SetShowName(0, TypeOf(CelestialObject), 0);

Global ImpulsiveBurn burn;
burn.AttitudeSystem = 6;


Global FileInterface file;


Define Procedure OpenForRead(String filename);
	file.Filename = filename;
	file.ReadMode = 1;
	file.WriteMode = 0;
	file.Open();
EndProcedure;

Define Procedure OpenForWrite(String filename);
	file.Filename = filename;
	file.ReadMode = 0;
	file.WriteMode = 1;
	file.Open();
EndProcedure;

Global ViewFont vf;
vf.Size = 14;

// Set initial states
Variable baseRAAN = 40;
Variable baseI = 0.5;
blue[0].SetKeplerianState({42164,
                           1e-6,
                           baseI,
                           baseRAAN,
                           1,
                           1});
                           
blue[0].Epoch = simStartEpoch;
blue[0].Color = colorBlue1;
blue[0].BodyScale = 1000;
blue[0].DisplayName = "BlueSat";
blue[0].Propagator.StepSize = simStepSize;
blue[0].EulerAngles[1] = 90;
blue[0].TailLength = radialViewTailLength;
radialView.SetShowName(blue[0].ObjectId, 1);
radialView.SetObjectLabelFont(blue[0].ObjectId, vf);


Variable red1AngularSeparation = 2;
Variable red2AngularSeparation = 2.5;
Variable red2and3RadialSeparation = 60;
red[0].SetKeplerianState({42164,
                          1e-6,
                          baseI * 1.2,
                          baseRAAN - red1AngularSeparation,
                          1,
                          1});
red[1].SetKeplerianState({42164 - red2and3RadialSeparation,
                          1e-6,
                          baseI * 0.3,
                          baseRAAN - red2AngularSeparation * 1.7,
                          1,
                          1});
red[2].SetKeplerianState({42164 + red2and3RadialSeparation,
                          1e-6,
                          baseI * 0.3,
                          baseRAAN + red2AngularSeparation,
                          1,
                          1});
                          
red[0].Color = colorRed1;
red[1].Color = colorRed2;
red[2].Color = colorRed3;

Variable i;
For i = 0 to red.Count - 1;
	red[i].Epoch = simStartEpoch;
	red[i].BodyScale = 1000;
	red[i].DisplayName = "Red" + (i+1).ToString();
	red[i].TailLength = radialViewTailLength;
	radialView.SetShowName(red[i].ObjectId, 1);
	radialView.SetObjectLabelFont(red[i].ObjectId, vf);
End;


Global Array initialKepStateRed1 = red[0].GetKeplerianState();
Global TimeSpan simEpoch;

Global Variable rangeB1_R1;
Global Variable rangeB1_R2;
Global Variable rangeB1_R3;

Global PlotScatterSeries rangeAngleFromPayloadR1;
Global PlotScatterSeries rangeAngleFromPayloadR2;
Global PlotScatterSeries rangeAngleFromPayloadR3;

Global PlotScatterSeries rangeAngleFromPayloadR1CurrentLocation;
Global PlotScatterSeries rangeAngleFromPayloadR2CurrentLocation;
Global PlotScatterSeries rangeAngleFromPayloadR3CurrentLocation;

Global PlotScatterSeries rangeAngleFromPayloadR1Predict;
Global PlotScatterSeries rangeAngleFromPayloadR2Predict;
Global PlotScatterSeries rangeAngleFromPayloadR3Predict;

PlotScatterSeries rangeAngleKeepOutArea;
PlotScatterSeries rangeKeepOutArea;


// set up angle to sensative payload vs range plot
Global PlotWindow pwRange;
pwRange.SetBackgroundColorPalette("DarkGray");
pwRange.PlotTitle.Text = "Angle from Sensative Payload vs Range";
pwRange.PlotSubTitle.Visible = 0;
pwRange.HighQualityRendering = 1;
pwRange.PointsToUpdate = 5 * 300 / simStepSize.ToSeconds();
pwRange.MaxPoints = 3e2 * 300 / simStepSize.ToSeconds();
pwRange.UseMonitorMode = 1;
pwRange.AddSeries(rangeKeepOutArea);
pwRange.AddSeries(rangeAngleKeepOutArea);
pwRange.AddSeries(rangeAngleFromPayloadR1);
pwRange.AddSeries(rangeAngleFromPayloadR2);
pwRange.AddSeries(rangeAngleFromPayloadR3);
pwRange.AddSeries(rangeAngleFromPayloadR1CurrentLocation);
pwRange.AddSeries(rangeAngleFromPayloadR2CurrentLocation);
pwRange.AddSeries(rangeAngleFromPayloadR3CurrentLocation);
pwRange.AddSeries(rangeAngleFromPayloadR1Predict);
pwRange.AddSeries(rangeAngleFromPayloadR2Predict);
pwRange.AddSeries(rangeAngleFromPayloadR3Predict);
pwRange.XAxis.MaximumValue = 180;
pwRange.XAxis.MinimumValue = 0;
pwRange.XAxis.Title.Text = "Angle from Sensative Payload (deg)";
pwRange.YAxis.MaximumValue = 600;
pwRange.YAxis.MinimumValue = 0;
pwRange.YAxis.Title.Text = "Range (km)";
pwRange.Legend.Location = 3;

// rangeAngleFromPayloadXX
rangeAngleFromPayloadR1.Label = "Red1";
rangeAngleFromPayloadR2.Label = "Red2";
rangeAngleFromPayloadR3.Label = "Red3";

rangeAngleFromPayloadR1.LineColor = colorRed1;
rangeAngleFromPayloadR2.LineColor = colorRed2;
rangeAngleFromPayloadR3.LineColor = colorRed3;

rangeAngleFromPayloadR1.LineStyle = 0;
rangeAngleFromPayloadR2.LineStyle = 0;
rangeAngleFromPayloadR3.LineStyle = 0;

rangeAngleFromPayloadR1.LineWidth = 2;
rangeAngleFromPayloadR2.LineWidth = 2;
rangeAngleFromPayloadR3.LineWidth = 2;

// rangeAngleFromPayloadXXCurrentLocation
rangeAngleFromPayloadR1CurrentLocation.MarkersColor = colorRed1;
rangeAngleFromPayloadR2CurrentLocation.MarkersColor = colorRed2;
rangeAngleFromPayloadR3CurrentLocation.MarkersColor = colorRed3;

rangeAngleFromPayloadR1CurrentLocation.MarkersStyle = 1;
rangeAngleFromPayloadR2CurrentLocation.MarkersStyle = 1;
rangeAngleFromPayloadR3CurrentLocation.MarkersStyle = 1;

rangeAngleFromPayloadR1CurrentLocation.MarkersSize = 2;
rangeAngleFromPayloadR2CurrentLocation.MarkersSize = 2;
rangeAngleFromPayloadR3CurrentLocation.MarkersSize = 2;

rangeAngleFromPayloadR1CurrentLocation.MarkersVisible = 1;
rangeAngleFromPayloadR2CurrentLocation.MarkersVisible = 1;
rangeAngleFromPayloadR3CurrentLocation.MarkersVisible = 1;

rangeAngleFromPayloadR1CurrentLocation.LineVisible = 0;
rangeAngleFromPayloadR2CurrentLocation.LineVisible = 0;
rangeAngleFromPayloadR3CurrentLocation.LineVisible = 0;

rangeAngleFromPayloadR1CurrentLocation.ShowInLegend = 0;
rangeAngleFromPayloadR2CurrentLocation.ShowInLegend = 0;
rangeAngleFromPayloadR3CurrentLocation.ShowInLegend = 0;

rangeAngleFromPayloadR1CurrentLocation.AddPoints(0, 0);
rangeAngleFromPayloadR2CurrentLocation.AddPoints(0, 0);
rangeAngleFromPayloadR3CurrentLocation.AddPoints(0, 0);

// rangeAngleFromPayloadXXPredict
rangeAngleFromPayloadR1Predict.Label = "Red1 Predict";
rangeAngleFromPayloadR2Predict.Label = "Red2 Predict";
rangeAngleFromPayloadR3Predict.Label = "Red3 Predict";

rangeAngleFromPayloadR1Predict.LineColor = colorRed1;
rangeAngleFromPayloadR2Predict.LineColor = colorRed2;
rangeAngleFromPayloadR3Predict.LineColor = colorRed3;

rangeAngleFromPayloadR1Predict.LineStyle = 2;
rangeAngleFromPayloadR2Predict.LineStyle = 2;
rangeAngleFromPayloadR3Predict.LineStyle = 2;

rangeAngleFromPayloadR1Predict.LineWidth = 1;
rangeAngleFromPayloadR2Predict.LineWidth = 1;
rangeAngleFromPayloadR3Predict.LineWidth = 1;

// rangeAngleKeepOutArea
rangeAngleKeepOutArea.LineColor = ColorTools.Yellow;
rangeAngleKeepOutArea.LineWidth = 3;
rangeAngleKeepOutArea.LineStyle = 0;
rangeAngleKeepOutArea.Label = "Payload Keep Out Zone";
rangeAngleKeepOutArea.AddPoints({0, 0, 45, 90}, {0, 80, 80, 0});
rangeAngleKeepOutArea.AddPoints(rangeAngleKeepOutArea.Data[0,:]);

// rangeKeepOutArea
rangeKeepOutArea.LineColor = ColorTools.Orange;
rangeKeepOutArea.LineWidth = 3;
rangeKeepOutArea.LineStyle = 0;
rangeKeepOutArea.Label = "Range Keep Out Zone";
rangeKeepOutArea.AddPoints({0, 0, 180, 180}, {0, 30, 30, 0});
rangeKeepOutArea.AddPoints(rangeKeepOutArea.Data[0,:]);


// Set up longitude radius plot

Global PlotScatterSeries radiusLongitudeB1;
Global PlotScatterSeries radiusLongitudeR1;
Global PlotScatterSeries radiusLongitudeR2;
Global PlotScatterSeries radiusLongitudeR3;

Global PlotScatterSeries radiusLongitudeB1CurrentLocation;
Global PlotScatterSeries radiusLongitudeR1CurrentLocation;
Global PlotScatterSeries radiusLongitudeR2CurrentLocation;
Global PlotScatterSeries radiusLongitudeR3CurrentLocation;


Global PlotWindow pwRadiusLongitude;
pwRadiusLongitude.SetBackgroundColorPalette("DarkGray");
pwRadiusLongitude.PlotTitle.Text = "Longitude vs Radius";
pwRadiusLongitude.PlotSubTitle.Visible = 0;
pwRadiusLongitude.HighQualityRendering = 1;
pwRadiusLongitude.PointsToUpdate = 5 * 300 / simStepSize.ToSeconds();
//pwRadiusLongitude.MaxPoints = 1e3 * 300 / simStepSize.ToSeconds();
pwRadiusLongitude.MaxPoints = 1e3 * 300 / simStepSize.ToSeconds();
pwRadiusLongitude.UseMonitorMode = 1;
pwRadiusLongitude.AddSeries(radiusLongitudeB1);
pwRadiusLongitude.AddSeries(radiusLongitudeR1);
pwRadiusLongitude.AddSeries(radiusLongitudeR2);
pwRadiusLongitude.AddSeries(radiusLongitudeR3);
pwRadiusLongitude.AddSeries(radiusLongitudeB1CurrentLocation);
pwRadiusLongitude.AddSeries(radiusLongitudeR1CurrentLocation);
pwRadiusLongitude.AddSeries(radiusLongitudeR2CurrentLocation);
pwRadiusLongitude.AddSeries(radiusLongitudeR3CurrentLocation);
pwRadiusLongitude.XAxis.MaximumValue = blue[0].Longitude + 3;
pwRadiusLongitude.XAxis.MinimumValue = blue[0].Longitude - 3;
pwRadiusLongitude.XAxis.Title.Text = "Longitude (deg)";
pwRadiusLongitude.YAxis.MaximumValue = 42250;
pwRadiusLongitude.YAxis.MinimumValue = 42050;
pwRadiusLongitude.YAxis.Title.Text = "Radius (km)";

// radiusLongitudeXXCurrentLocation
radiusLongitudeB1CurrentLocation.MarkersColor = colorBlue1;
radiusLongitudeR1CurrentLocation.MarkersColor = colorRed1;
radiusLongitudeR2CurrentLocation.MarkersColor = colorRed2;
radiusLongitudeR3CurrentLocation.MarkersColor = colorRed3;

radiusLongitudeB1CurrentLocation.MarkersStyle = 1;
radiusLongitudeR1CurrentLocation.MarkersStyle = 1;
radiusLongitudeR2CurrentLocation.MarkersStyle = 1;
radiusLongitudeR3CurrentLocation.MarkersStyle = 1;

radiusLongitudeB1CurrentLocation.MarkersSize = 2;
radiusLongitudeR1CurrentLocation.MarkersSize = 2;
radiusLongitudeR2CurrentLocation.MarkersSize = 2;
radiusLongitudeR3CurrentLocation.MarkersSize = 2;

radiusLongitudeB1CurrentLocation.MarkersVisible = 1;
radiusLongitudeR1CurrentLocation.MarkersVisible = 1;
radiusLongitudeR2CurrentLocation.MarkersVisible = 1;
radiusLongitudeR3CurrentLocation.MarkersVisible = 1;

radiusLongitudeB1CurrentLocation.LineVisible = 0;
radiusLongitudeR1CurrentLocation.LineVisible = 0;
radiusLongitudeR2CurrentLocation.LineVisible = 0;
radiusLongitudeR3CurrentLocation.LineVisible = 0;

radiusLongitudeB1CurrentLocation.ShowInLegend = 0;
radiusLongitudeR1CurrentLocation.ShowInLegend = 0;
radiusLongitudeR2CurrentLocation.ShowInLegend = 0;
radiusLongitudeR3CurrentLocation.ShowInLegend = 0;

radiusLongitudeB1CurrentLocation.AddPoints(0, 0);
radiusLongitudeR1CurrentLocation.AddPoints(0, 0);
radiusLongitudeR2CurrentLocation.AddPoints(0, 0);
radiusLongitudeR3CurrentLocation.AddPoints(0, 0);

// radiusLongitude
radiusLongitudeB1.Label = "BlueSat";
radiusLongitudeR1.Label = "Red1";
radiusLongitudeR2.Label = "Red2";
radiusLongitudeR3.Label = "Red3";

radiusLongitudeB1.LineColor = colorBlue1;
radiusLongitudeR1.LineColor = colorRed1;
radiusLongitudeR2.LineColor = colorRed2;
radiusLongitudeR3.LineColor = colorRed3;

radiusLongitudeB1.LineStyle = 0;
radiusLongitudeR1.LineStyle = 0;
radiusLongitudeR2.LineStyle = 0;
radiusLongitudeR3.LineStyle = 0;

radiusLongitudeB1.LineWidth = 2;
radiusLongitudeR1.LineWidth = 2;
radiusLongitudeR2.LineWidth = 2;
radiusLongitudeR3.LineWidth = 2;

Call AddVerticalLine(
	pwRadiusLongitude,
	pwRadiusLongitude.XAxis.MinimumValue + (pwRadiusLongitude.XAxis.MaximumValue - pwRadiusLongitude.XAxis.MinimumValue) * 0.88,
	{pwRadiusLongitude.YAxis.MinimumValue + (pwRadiusLongitude.YAxis.MaximumValue - pwRadiusLongitude.YAxis.MinimumValue) * 0.17, pwRadiusLongitude.YAxis.MinimumValue + 10},
	2,
	ColorTools.Green,
	0,
	"");
Call AddFloatingLabelToPlot(
	pwRadiusLongitude,
	pwRadiusLongitude.XAxis.MinimumValue + (pwRadiusLongitude.XAxis.MaximumValue - pwRadiusLongitude.XAxis.MinimumValue) * 0.88,
	pwRadiusLongitude.YAxis.MinimumValue + (pwRadiusLongitude.YAxis.MaximumValue - pwRadiusLongitude.YAxis.MinimumValue) * 0.15,
	ColorTools.Green,
	ColorTools.LightGray,
	"Candara",
	16,
	"To Earth");
Call AddSinglePointToPlot(
	pwRadiusLongitude,
	pwRadiusLongitude.XAxis.MinimumValue + (pwRadiusLongitude.XAxis.MaximumValue - pwRadiusLongitude.XAxis.MinimumValue) * 0.88,
	pwRadiusLongitude.YAxis.MinimumValue + 10,
	5,
	3,
	ColorTools.Green,
	"");






OutputLayout.SetWindowFrameVisibility({radialView.ID, pwRadiusLongitude.ID, pwRange.ID}, 0);
OutputLayout.SetWindowPosition(pwRadiusLongitude.ID, 1, 0, 1, 0);
OutputLayout.SetWindowSize(pwRadiusLongitude.ID, 1, 0.4, 1, 0.5);
OutputLayout.SetWindowPosition(pwRange.ID, 1, 0, 1, 0.5);
OutputLayout.SetWindowSize(pwRange.ID, 1, 0.4, 1, 0.5);
OutputLayout.SetWindowPosition(radialView.ID, 1, 0.4, 1, 0);
OutputLayout.SetWindowSize(radialView.ID, 1, 0.6, 1, 1);
OutputLayout.ApplyUpdates();]]></FreeFormScript>
      </FreeForm>
      <FreeForm enabled="true">
        <Label>Procedures</Label>
        <Bookmarks />
        <Breakpoints />
        <FreeFormScript><![CDATA[

Define Procedure ComputePredict(Spacecraft primarySC, Spacecraft secondarySC, TimeSpan predictionDuration, GraphicsOverlay go, PlotScatterSeries angleRangeSeries, Variable justEraseOverlay);
	Array positionBCS;
	Variable i;
	
	
	Matrix futureStateMJ2000 = Matrix.Empty;
	futureStateMJ2000.ColumnCount = 3;
	
	TimeSpan currentStep = TimeSpan.Zero();
	
	// Reset the GraphicsOverlay
	go.ClearOverlayElements();
	angleRangeSeries.ClearPoints();
	
	If (justEraseOverlay);
		ExitProcedure;
	End;
	
	Save primarySC;
	Save secondarySC;
	primarySC.Propagator.StepSize = TimeSpan.FromSeconds(300);
	
    // Compute the future path of the secondary with respect to the primary
	TimeSpan epochToStepTo = primarySC.Epoch + predictionDuration;
	WhileStepping primarySC to (primarySC.Epoch == epochToStepTo);
		secondarySC.StepToEpoch(primarySC.Epoch);
		
		positionBCS = AttitudeConvert(0, 3, primarySC, secondarySC.Position - primarySC.Position);
		
		go.AddOverlayElement(positionBCS[0], positionBCS[1], positionBCS[2]);
		
		angleRangeSeries.AddPoints(deg(acos(positionBCS.Normalized.DotProduct(sensativePayloadUnitVectorBCS.Normalized))), positionBCS.Norm);
	End;

	
	Restore primarySC;
	Restore secondarySC;
	
EndProcedure;


Define Procedure ComputeStationKeepingManeuver(Optimizer opt, Spacecraft sc, Variable longitude);
	TimeSpan initialEpoch;
	opt.Reset(1);
	opt.AddStateVariableBlock(3, "dv", 0.0001, -0.001, 0.001, 1, 1e-6);
	
	opt.SaveObjectToProcess(sc);
	
	opt.MaximumNominalEvaluationCount = 50;
	opt.LoadEngine();
	While (opt.IsRunning());
		opt.UpdateStateVariables();
		opt.RestoreObjectsInProcess();
		burn.BurnDirection = opt.GetStateVariableValues();
		
		sc.Maneuver(burn);
		
		initialEpoch = sc.Epoch;
		While (abs(sc.Longitude - longitude) < 0.05);
			sc.Step(TimeSpan.FromSeconds(30));
		End;
		
		opt.Maximize((sc.Epoch - initialEpoch).ToHours());
		
		If (opt.OptimizationPhase == 1);
			Report opt.NominalEvaluationCount, opt.ObjectiveFunctionValue, burn.BurnDirection.Norm, opt.MaximumInfeasibility, opt.MaximumInfeasibilitySource;
		End;
	End;
	
	Report opt.ReturnString;
	opt.RestoreObjectsInProcess();
EndProcedure;

Define Procedure ComputeRangeAndAngleFromPayload(Spacecraft blue, Spacecraft red, Variable range, Variable angle);
	Array positionBCS;
	
	positionBCS = AttitudeConvert(0, 3, blue, red.Position - blue.Position);
	range = positionBCS.Norm;
	angle = deg(acos(positionBCS.Normalized.DotProduct(sensativePayloadUnitVectorBCS.Normalized)));
EndProcedure;

Define Procedure AdvanceSimToFutureEpoch(Formation red, Formation blue, TimeSpan futureEpoch);
	TimeSpan timeSinceAheadPredictUpdate = TimeSpan.Zero();
	
	Variable angle;
	
	WhileStepping blue[0] to (blue[0].Epoch == futureEpoch);
		pwRange.BeginBatchUpdate();
		red.StepToEpoch(blue[0].Epoch);
		simEpoch = blue[0].Epoch;
	
		// update angle vs range data
		Call ComputeRangeAndAngleFromPayload(blue[0], red[0], rangeB1_R1, angle);
		rangeAngleFromPayloadR1.AddPoints(angle, rangeB1_R1);
		rangeAngleFromPayloadR1CurrentLocation.Data[0, 0:1] = rangeAngleFromPayloadR1.Data[rangeAngleFromPayloadR1.Data.RowCount - 1, 0:1];
		
		Call ComputeRangeAndAngleFromPayload(blue[0], red[1], rangeB1_R2, angle);
		rangeAngleFromPayloadR2.AddPoints(angle, rangeB1_R2);
		rangeAngleFromPayloadR2CurrentLocation.Data[0, 0:1] = rangeAngleFromPayloadR2.Data[rangeAngleFromPayloadR2.Data.RowCount - 1, 0:1];
		
		Call ComputeRangeAndAngleFromPayload(blue[0], red[2], rangeB1_R3, angle);
		rangeAngleFromPayloadR3.AddPoints(angle, rangeB1_R3);
		rangeAngleFromPayloadR3CurrentLocation.Data[0, 0:1] = rangeAngleFromPayloadR3.Data[rangeAngleFromPayloadR3.Data.RowCount - 1, 0:1];

		// update longitude vs radius data
		radiusLongitudeB1.AddPoints(blue[0].Longitude, blue[0].Radius);
		radiusLongitudeR1.AddPoints(red[0].Longitude, red[0].Radius);
		radiusLongitudeR2.AddPoints(red[1].Longitude, red[1].Radius);
		radiusLongitudeR3.AddPoints(red[2].Longitude, red[2].Radius);
		radiusLongitudeB1CurrentLocation.Data[0, 0:1] = radiusLongitudeB1.Data[radiusLongitudeB1.Data.RowCount - 1, 0:1];
		radiusLongitudeR1CurrentLocation.Data[0, 0:1] = radiusLongitudeR1.Data[radiusLongitudeR1.Data.RowCount - 1, 0:1];
		radiusLongitudeR2CurrentLocation.Data[0, 0:1] = radiusLongitudeR2.Data[radiusLongitudeR2.Data.RowCount - 1, 0:1];
		radiusLongitudeR3CurrentLocation.Data[0, 0:1] = radiusLongitudeR3.Data[radiusLongitudeR3.Data.RowCount - 1, 0:1];
		
		// update predict data
		timeSinceAheadPredictUpdate += blue[0].Propagator.StepSize;
		If (timeSinceAheadPredictUpdate > aheadPredictUpdateInterval);
			Call ComputePredict(blue[0], red[0], aheadPredictTime, overlayRed1Future, rangeAngleFromPayloadR1Predict, rangeB1_R1 > aheadPredictRangeUpdateLimit);
			Call ComputePredict(blue[0], red[1], aheadPredictTime, overlayRed2Future, rangeAngleFromPayloadR2Predict, rangeB1_R2 > aheadPredictRangeUpdateLimit);
			Call ComputePredict(blue[0], red[2], aheadPredictTime, overlayRed3Future, rangeAngleFromPayloadR3Predict, rangeB1_R3 > aheadPredictRangeUpdateLimit);
			timeSinceAheadPredictUpdate = TimeSpan.Zero;
		End;
		
		
		pwRange.EndBatchUpdate();
		pwRadiusLongitude.Update();
		radialView.Update();
	End;
EndProcedure;


Define Procedure BenignScript(Formation red, Formation blue);
	Optimizer opt;
	TimeSpan initialEpoch;
	
	TimeSpan futureEpoch = blue[0].Epoch + TimeSpan.FromDays(1);
	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);
	
//Block PRESOLVED OPTIMIZATION
	If (doOptimizationAndSaveValues);
		Call ComputeStationKeepingManeuver(opt, blue[0], 279.25);
		burn.BurnDirection = opt.GetBestStateVariableValues();
		
		Call OpenForWrite("SavedValues/BenignScript_Blue1SK1.txt");
		file.PutLine(burn.BurnDirection[0].ToString());
		file.PutLine(burn.BurnDirection[1].ToString());
		file.PutLine(burn.BurnDirection[2].ToString());
		file.Close();
	End;
//EndBlock PRESOLVED OPTIMIZATION

	Call OpenForRead("SavedValues/BenignScript_Blue1SK1.txt");
	burn.BurnDirection[0] = file.GetLine().ToVariable();
	burn.BurnDirection[1] = file.GetLine().ToVariable();
	burn.BurnDirection[2] = file.GetLine().ToVariable();
	file.Close();
	
	blue[0].Maneuver(burn);
	
	futureEpoch = blue[0].Epoch + TimeSpan.FromDays(1);
	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);
	
	//Block PRESOLVED OPTIMIZATION
	If (doOptimizationAndSaveValues);
		Call ComputeStationKeepingManeuver(opt, red[0], 277.3);
		burn.BurnDirection = opt.GetBestStateVariableValues();
		
		Call OpenForWrite("SavedValues/BenignScript_Red1SK1.txt");
		file.PutLine(burn.BurnDirection[0].ToString());
		file.PutLine(burn.BurnDirection[1].ToString());
		file.PutLine(burn.BurnDirection[2].ToString());
		file.Close();
	End;
//EndBlock PRESOLVED OPTIMIZATION

	Call OpenForRead("SavedValues/BenignScript_Red1SK1.txt");
	burn.BurnDirection[0] = file.GetLine().ToVariable();
	burn.BurnDirection[1] = file.GetLine().ToVariable();
	burn.BurnDirection[2] = file.GetLine().ToVariable();
	file.Close();
	
	red[0].Maneuver(burn);
	
	futureEpoch = blue[0].Epoch + TimeSpan.FromDays(7);
	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);
	
EndProcedure;


Define Procedure ObservationScript(Formation red, Formation blue);
	
	Array relativePos;
	Array relativeVel;
	Array desiredRelativePosLVC;
	Variable relativeStateObjective;
	Optimizer opt;
	NloptOptions nlopt;
	TimeSpan initialEpoch;
	Variable maxDistance;
	Variable minDistance;
	Variable minAngle;
	Variable distance;
	Variable angle;
	
	TimeSpan futureEpoch = blue[0].Epoch + TimeSpan.FromDays(1);
	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);
	
//Block PRESOLVED OPTIMIZATION
	If (doOptimizationAndSaveValues);
		Call ComputeStationKeepingManeuver(opt, blue[0], 279.25);
		burn.BurnDirection = opt.GetBestStateVariableValues();
		
		Call OpenForWrite("SavedValues/ObservationScript_Blue1SK1.txt");
		file.PutLine(burn.BurnDirection[0].ToString());
		file.PutLine(burn.BurnDirection[1].ToString());
		file.PutLine(burn.BurnDirection[2].ToString());
		file.Close();
	End;
//EndBlock PRESOLVED OPTIMIZATION

	Call OpenForRead("SavedValues/ObservationScript_Blue1SK1.txt");
	burn.BurnDirection[0] = file.GetLine().ToVariable();
	burn.BurnDirection[1] = file.GetLine().ToVariable();
	burn.BurnDirection[2] = file.GetLine().ToVariable();
	file.Close();
	
	blue[0].Maneuver(burn);

//Block PRESOLVED OPTIMIZATION
	If (doOptimizationAndSaveValues);
		desiredRelativePosLVC = {0, 0, 60};

		opt.Reset(1);
		opt.AddStateVariableBlock(3, "dv", 0.001, -0.01, 0.01);
		opt.AddStateVariable("days", 7, 6.7, 7.3);
		opt.AddConstraintBlock(3, "relativePos", 0, 0, 100);
		opt.AddConstraint("crossTrackVel", 0, 0);
		
		opt.SaveObjectToProcess(red[0]);
		opt.SaveObjectToProcess(blue[0]);
		
		opt.LoadEngine();
		While (opt.IsRunning());
			opt.UpdateStateVariables();
			opt.RestoreObjectsInProcess();
			burn.BurnDirection = opt.GetStateVariableValues()[0:2];
			
			red[0].Maneuver(burn);
			
			futureEpoch = blue[0].Epoch + TimeSpan.FromDays(opt.GetStateVariableValue("days"));
			WhileStepping blue[0] to (blue[0].Epoch == futureEpoch);
				red[0].StepToEpoch(blue[0].Epoch);
			End;
			
			relativePos = RelativeMotionUtilities.ConvertRelativePosition(0, 6, red[0], blue[0].Position - red[0].Position);
			relativeVel = RelativeMotionUtilities.ConvertRelativeVelocity(0, 6, red[0], blue[0].GetCartesianState() - red[0].GetCartesianState());
//			relativePos[2] = desiredRelativePosLVC[2]; // we don't care about cross track so zero it out
			opt.SetConstraintValues({desiredRelativePosLVC - relativePos, relativeVel[2]});
			
			opt.Minimize(burn.BurnDirection.Norm);
			
			If (opt.OptimizationPhase == 1);
				Report opt.NominalEvaluationCount, opt.ObjectiveFunctionValue, opt.MaximumInfeasibility, opt.MaximumInfeasibilitySource;
			End;
		End;
		
		Report opt.ReturnString;
		opt.RestoreObjectsInProcess();
		
		burn.BurnDirection = opt.GetBestStateVariableValues()[0:2];
		
		Call OpenForWrite("SavedValues/ObservationScript_Red1Burn1.txt");
		file.PutLine(burn.BurnDirection[0].ToString());
		file.PutLine(burn.BurnDirection[1].ToString());
		file.PutLine(burn.BurnDirection[2].ToString());
		file.PutLine(opt.GetBestStateVariableValue("days").ToString());
		file.Close();
	End;
//EndBlock PRESOLVED OPTIMIZATION
	
	Call OpenForRead("SavedValues/ObservationScript_Red1Burn1.txt");
	burn.BurnDirection[0] = file.GetLine().ToVariable();
	burn.BurnDirection[1] = file.GetLine().ToVariable();
	burn.BurnDirection[2] = file.GetLine().ToVariable();
	futureEpoch = blue[0].Epoch + TimeSpan.FromDays(file.GetLine().ToVariable());
	file.Close();

	red[0].Maneuver(burn);

	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);
	

//Block PRESOLVED OPTIMIZATION
	If (doOptimizationAndSaveValues);
		desiredRelativePosLVC = RelativeMotionUtilities.ConvertRelativePosition(0, 6, red[0], blue[0].Position - red[0].Position);

		opt.Reset(1);
		opt.MaximumNominalEvaluationCount = 1800;
		opt.AddStateVariableBlock(3, "dv", 0.001, -0.01, 0.01);
		opt.AddConstraint("minAngle", -1e-20, 15);
		opt.AddConstraint("minDistance", 50, 1e20);
		opt.AddConstraint("maxDistance", -1e20, 80);
		
		opt.SaveObjectToProcess(red[0]);
		opt.SaveObjectToProcess(blue[0]);
		
		nlopt.AlgorithmToUse = 38;
		nlopt.SubsidiaryAlgorithmToUse = 40;
		
		opt.LoadEngine();
		While (opt.IsRunning());
			opt.UpdateStateVariables();
			opt.RestoreObjectsInProcess();
			burn.BurnDirection = opt.GetStateVariableValues();
			
			red[0].Maneuver(burn);
			
			futureEpoch = blue[0].Epoch + TimeSpan.FromDays(1);
			Call ComputeRangeAndAngleFromPayload(blue[0], red[0], distance, angle);
			minDistance = distance;
			maxDistance = distance;
			minAngle = angle;
			WhileStepping blue[0] to (blue[0].Epoch == futureEpoch);
				red[0].StepToEpoch(blue[0].Epoch);
				Call ComputeRangeAndAngleFromPayload(blue[0], red[0], distance, angle);
				If (distance < minDistance);
					minDistance = distance;
				End;
				If (distance > maxDistance);
					maxDistance = distance;
				End;
				If (angle < minAngle);
					minAngle = angle;
				End;
			End;
			
			opt.SetConstraintValue("minAngle", minAngle);
			opt.SetConstraintValue("minDistance", minDistance);
			opt.SetConstraintValue("maxDistance", maxDistance);
			
			opt.Minimize(burn.BurnDirection.Norm * 1e0);
						
			If (opt.OptimizationPhase == 1);
				Report opt.NominalEvaluationCount, burn.BurnDirection.Norm, minAngle, minDistance, maxDistance, opt.MaximumInfeasibility, opt.MaximumInfeasibilitySource;
			End;
			
//			futureEpoch = blue[0].Epoch + TimeSpan.FromDays(0.25);
//			WhileStepping blue[0] to (blue[0].Epoch == futureEpoch);
//				red[0].StepToEpoch(blue[0].Epoch);
//			End;
//			
//			relativeStateObjective = abs((blue[0].Position - red[0].Position).Norm - desiredRelativePosLVC.Norm());
//			
//			futureEpoch = blue[0].Epoch + TimeSpan.FromDays(0.25);
//			WhileStepping blue[0] to (blue[0].Epoch == futureEpoch);
//				red[0].StepToEpoch(blue[0].Epoch);
//			End;
//			
//			relativePos = RelativeMotionUtilities.ConvertRelativePosition(0, 6, red[0], blue[0].Position - red[0].Position);
//			relativeStateObjective += (-desiredRelativePosLVC - relativePos).Norm;
//			
//			futureEpoch = blue[0].Epoch + TimeSpan.FromDays(0.25);
//			WhileStepping blue[0] to (blue[0].Epoch == futureEpoch);
//				red[0].StepToEpoch(blue[0].Epoch);
//			End;
//			
//			relativeStateObjective += abs((blue[0].Position - red[0].Position).Norm - desiredRelativePosLVC.Norm());
//			
//			futureEpoch = blue[0].Epoch + TimeSpan.FromDays(0.25);
//			WhileStepping blue[0] to (blue[0].Epoch == futureEpoch);
//				red[0].StepToEpoch(blue[0].Epoch);
//			End;
//			
//			relativePos = RelativeMotionUtilities.ConvertRelativePosition(0, 6, red[0], blue[0].Position - red[0].Position);
//			relativeStateObjective += (desiredRelativePosLVC - relativePos).Norm;
//			
//			opt.Minimize(burn.BurnDirection.Norm * 1e2 + relativeStateObjective*1e0);
//			
//			If (opt.OptimizationPhase == 1);
//				Report opt.NominalEvaluationCount, burn.BurnDirection.Norm, relativeStateObjective, opt.MaximumInfeasibility, opt.MaximumInfeasibilitySource;
//			End;
		End;
		
		Report opt.ReturnString;
		opt.RestoreObjectsInProcess();
		
		burn.BurnDirection = opt.GetBestStateVariableValues();
		
		Call OpenForWrite("SavedValues/ObservationScript_Red1Burn2.txt");
		file.PutLine(burn.BurnDirection[0].ToString());
		file.PutLine(burn.BurnDirection[1].ToString());
		file.PutLine(burn.BurnDirection[2].ToString());
		file.Close();
	End;
//EndBlock PRESOLVED OPTIMIZATION
	
	Call OpenForRead("SavedValues/ObservationScript_Red1Burn2.txt");
	burn.BurnDirection[0] = file.GetLine().ToVariable();
	burn.BurnDirection[1] = file.GetLine().ToVariable();
	burn.BurnDirection[2] = file.GetLine().ToVariable();
	file.Close();
	
	red[0].Maneuver(burn);
	
	futureEpoch = blue[0].Epoch + TimeSpan.FromDays(1);
	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);
	
	burn.BurnDirection = -{    0.000145506,       -0.000805460,       -0.000000254};
	red[0].Maneuver(burn);
	
	futureEpoch = blue[0].Epoch + TimeSpan.FromDays(7);
	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);
	
EndProcedure;


Define Procedure DisableScript(Formation red, Formation blue);
	
	Array relativePos;
	Array desiredRelativePosLVC;
	Optimizer opt;
	Variable relativeStateObjective;
	NloptOptions nlopt;
	Array kepState;
	Variable totalDV;
	TimeSpan initialEpoch;
	
	TimeSpan futureEpoch = blue[0].Epoch + TimeSpan.FromDays(1);
	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);
	
//Block PRESOLVED OPTIMIZATION
	If (doOptimizationAndSaveValues);
		Call ComputeStationKeepingManeuver(opt, blue[0], 279.25);
		burn.BurnDirection = opt.GetBestStateVariableValues();
		
		Call OpenForWrite("SavedValues/DisableScript_Blue1SK1.txt");
		file.PutLine(burn.BurnDirection[0].ToString());
		file.PutLine(burn.BurnDirection[1].ToString());
		file.PutLine(burn.BurnDirection[2].ToString());
		file.Close();
	End;
//EndBlock PRESOLVED OPTIMIZATION

	Call OpenForRead("SavedValues/DisableScript_Blue1SK1.txt");
	burn.BurnDirection[0] = file.GetLine().ToVariable();
	burn.BurnDirection[1] = file.GetLine().ToVariable();
	burn.BurnDirection[2] = file.GetLine().ToVariable();
	file.Close();
	
	blue[0].Maneuver(burn);
	
//Block PRESOLVED OPTIMIZATION
	If (doOptimizationAndSaveValues);
		desiredRelativePosLVC = {0, 4, 2};
		
		opt.Reset(1);
		opt.AddStateVariableBlock(3, "dv", 0.001, -0.01, 0.01);
		opt.AddConstraintBlock(3, "relativePos", 0, 0);
		
		opt.SaveObjectToProcess(red[0]);
		opt.SaveObjectToProcess(blue[0]);
		
		opt.LoadEngine();
		While (opt.IsRunning());
			opt.UpdateStateVariables();
			opt.RestoreObjectsInProcess();
			burn.BurnDirection = opt.GetStateVariableValues();
			
			red[0].Maneuver(burn);
			
			futureEpoch = blue[0].Epoch + TimeSpan.FromDays(4);
			WhileStepping blue[0] to (blue[0].Epoch == futureEpoch);
				red[0].StepToEpoch(blue[0].Epoch);
			End;
			
			relativePos = RelativeMotionUtilities.ConvertRelativePosition(0, 6, red[0], blue[0].Position - red[0].Position);
			relativePos[2] = desiredRelativePosLVC[2]; // we don't care about cross track so zero it out
			opt.SetConstraintValues(desiredRelativePosLVC - relativePos);
			
			opt.Minimize(burn.BurnDirection.Norm);
			
			If (opt.OptimizationPhase == 1);
				Report opt.NominalEvaluationCount, opt.ObjectiveFunctionValue, opt.MaximumInfeasibility, opt.MaximumInfeasibilitySource;
			End;
		End;
		
		Report opt.ReturnString;
		opt.RestoreObjectsInProcess();
		
		burn.BurnDirection = opt.GetBestStateVariableValues();
		
		Call OpenForWrite("SavedValues/DisableScript_Red1Burn1.txt");
		file.PutLine(burn.BurnDirection[0].ToString());
		file.PutLine(burn.BurnDirection[1].ToString());
		file.PutLine(burn.BurnDirection[2].ToString());
		file.Close();
	End;
//EndBlock PRESOLVED OPTIMIZATION

	Call OpenForRead("SavedValues/DisableScript_Red1Burn1.txt");
	burn.BurnDirection[0] = file.GetLine().ToVariable();
	burn.BurnDirection[1] = file.GetLine().ToVariable();
	burn.BurnDirection[2] = file.GetLine().ToVariable();
	file.Close();

	red[0].Maneuver(burn);

	futureEpoch = blue[0].Epoch + TimeSpan.FromDays(4);
	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);

//Block PRESOLVED OPTIMIZATION
	If (doOptimizationAndSaveValues);
		desiredRelativePosLVC = RelativeMotionUtilities.ConvertRelativePosition(0, 6, red[0], blue[0].Position - red[0].Position);
		
		opt.Reset(1);
		opt.MaximumNominalEvaluationCount = 800;
		opt.AddStateVariableBlock(3, "dv", 0.001, -0.01, 0.01);
		
		opt.SaveObjectToProcess(red[0]);
		opt.SaveObjectToProcess(blue[0]);
		
		nlopt.AlgorithmToUse = 38;
		nlopt.SubsidiaryAlgorithmToUse = 40;
		
		opt.LoadEngine(nlopt);
		While (opt.IsRunning());
			opt.UpdateStateVariables();
			opt.RestoreObjectsInProcess();
			burn.BurnDirection = opt.GetStateVariableValues();
			
			red[0].Maneuver(burn);
			
			futureEpoch = blue[0].Epoch + TimeSpan.FromDays(0.5);
			WhileStepping blue[0] to (blue[0].Epoch == futureEpoch);
				red[0].StepToEpoch(blue[0].Epoch);
			End;
			
			relativePos = RelativeMotionUtilities.ConvertRelativePosition(0, 6, red[0], blue[0].Position - red[0].Position);
			relativeStateObjective = (-desiredRelativePosLVC - relativePos).Norm;
			
			futureEpoch = blue[0].Epoch + TimeSpan.FromDays(0.5);
			WhileStepping blue[0] to (blue[0].Epoch == futureEpoch);
				red[0].StepToEpoch(blue[0].Epoch);
			End;
			
			relativePos = RelativeMotionUtilities.ConvertRelativePosition(0, 6, red[0], blue[0].Position - red[0].Position);
			relativeStateObjective += (desiredRelativePosLVC - relativePos).Norm;
			
			opt.Minimize(burn.BurnDirection.Norm * 1e3 + relativeStateObjective*1e0);
			
			If (opt.OptimizationPhase == 1);
				Report opt.NominalEvaluationCount, opt.ObjectiveFunctionValue, opt.MaximumInfeasibility, opt.MaximumInfeasibilitySource;
			End;
		End;
		
		Report opt.ReturnString;
		opt.RestoreObjectsInProcess();
		
		burn.BurnDirection = opt.GetBestStateVariableValues();
		
		Call OpenForWrite("SavedValues/DisableScript_Red1Burn2.txt");
		file.PutLine(burn.BurnDirection[0].ToString());
		file.PutLine(burn.BurnDirection[1].ToString());
		file.PutLine(burn.BurnDirection[2].ToString());
		file.Close();
	End;

//EndBlock PRESOLVED OPTIMIZATION

	Call OpenForRead("SavedValues/DisableScript_Red1Burn2.txt");
	burn.BurnDirection[0] = file.GetLine().ToVariable();
	burn.BurnDirection[1] = file.GetLine().ToVariable();
	burn.BurnDirection[2] = file.GetLine().ToVariable();
	file.Close();


	red[0].Maneuver(burn);
	
	TimeSpan preDeployWaitTime = TimeSpan.FromDays(0.1);
	TimeSpan rendezvousTime = TimeSpan.FromDays(0.3);
	TimeSpan killOperationTime = TimeSpan.FromDays(0.2);
	
	futureEpoch = blue[0].Epoch + preDeployWaitTime;
	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);
	
	// Deploy inspector from Red 1
	red.Count += 1;
	Alias deployableSat = red[red.Count - 1];
	deployableSat.BodyScale = 200;
	deployableSat.DisplayName = "RedSat" + red.Count.ToString();
	deployableSat.Color = colorRed4;
	deployableSat.TailLength = radialViewTailLength/4;
	radialView.SetShowName(deployableSat.ObjectId, 1);
	radialView.SetObjectLabelFont(deployableSat.ObjectId, vf);
	
	deployableSat.Epoch = red[0].Epoch;
	deployableSat.SetCartesianState(red[0].GetCartesianState());

//Block PRESOLVED OPTIMIZATION
	If (doOptimizationAndSaveValues);
		desiredRelativePosLVC = {0, 0, 0};
		
		opt.Reset(1);
		opt.AddStateVariableBlock(3, "dv", 0.001, -0.01, 0.01);
		opt.AddConstraintBlock(3, "relativePos", 0, 0);
		
		opt.SaveObjectToProcess(deployableSat);
		opt.SaveObjectToProcess(blue[0]);
		
		opt.LoadEngine();
		While (opt.IsRunning());
			opt.UpdateStateVariables();
			opt.RestoreObjectsInProcess();
			burn.BurnDirection = opt.GetStateVariableValues();
			
			deployableSat.Maneuver(burn);
			
			futureEpoch = blue[0].Epoch + rendezvousTime;
			WhileStepping blue[0] to (blue[0].Epoch == futureEpoch);
				deployableSat.StepToEpoch(blue[0].Epoch);
			End;
			
			relativePos = RelativeMotionUtilities.ConvertRelativePosition(0, 6, deployableSat, blue[0].Position - deployableSat.Position);
			opt.SetConstraintValues(desiredRelativePosLVC - relativePos);
			
			opt.Minimize(burn.BurnDirection.Norm);
			
			If (opt.OptimizationPhase == 1);
				Report opt.NominalEvaluationCount, opt.ObjectiveFunctionValue, opt.MaximumInfeasibility, opt.MaximumInfeasibilitySource;
			End;
		End;
		
		Report opt.ReturnString;
		opt.RestoreObjectsInProcess();
		
		burn.BurnDirection = opt.GetBestStateVariableValues();
		Report burn.BurnDirection;
		
		Call OpenForWrite("SavedValues/DisableScript_Red1Burn3.txt");
		file.PutLine(burn.BurnDirection[0].ToString());
		file.PutLine(burn.BurnDirection[1].ToString());
		file.PutLine(burn.BurnDirection[2].ToString());
		file.Close();
	End;
//EndBlock PRESOLVED OPTIMIZATION
	
	Call OpenForRead("SavedValues/DisableScript_Red1Burn3.txt");
	burn.BurnDirection[0] = file.GetLine().ToVariable();
	burn.BurnDirection[1] = file.GetLine().ToVariable();
	burn.BurnDirection[2] = file.GetLine().ToVariable();
	file.Close();
	
	deployableSat.Maneuver(burn);
	
	futureEpoch = blue[0].Epoch + rendezvousTime;
	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);
	
	deployableSat.SetCartesianState(blue[0].GetCartesianState());
	
	futureEpoch = blue[0].Epoch + killOperationTime;
	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);
	
	// Inspector return to Red 1
	
//Block PRESOLVED OPTIMIZATION
	If (doOptimizationAndSaveValues);
		desiredRelativePosLVC = {0, 0, 0};
		
		opt.Reset(1);
		opt.AddStateVariableBlock(3, "dv", 0.001, -0.01, 0.01);
		opt.AddConstraintBlock(3, "relativePos", 0, 0);
		
		opt.SaveObjectToProcess(deployableSat);
		opt.SaveObjectToProcess(red[0]);
		
		opt.LoadEngine();
		While (opt.IsRunning());
			opt.UpdateStateVariables();
			opt.RestoreObjectsInProcess();
			burn.BurnDirection = opt.GetStateVariableValues();
			
			deployableSat.Maneuver(burn);
			
			futureEpoch = red[0].Epoch + rendezvousTime;
			WhileStepping red[0] to (red[0].Epoch == futureEpoch);
				deployableSat.StepToEpoch(red[0].Epoch);
			End;
			
			relativePos = RelativeMotionUtilities.ConvertRelativePosition(0, 6, deployableSat, red[0].Position - deployableSat.Position);
			opt.SetConstraintValues(desiredRelativePosLVC - relativePos);
			
			opt.Minimize(burn.BurnDirection.Norm);
			
			If (opt.OptimizationPhase == 1);
				Report opt.NominalEvaluationCount, opt.ObjectiveFunctionValue, opt.MaximumInfeasibility, opt.MaximumInfeasibilitySource;
			End;
		End;
		
		Report opt.ReturnString;
		opt.RestoreObjectsInProcess();
		
		burn.BurnDirection = opt.GetBestStateVariableValues();
		
		Call OpenForWrite("SavedValues/DisableScript_Red1Burn4.txt");
		file.PutLine(burn.BurnDirection[0].ToString());
		file.PutLine(burn.BurnDirection[1].ToString());
		file.PutLine(burn.BurnDirection[2].ToString());
		file.Close();
	End;
//EndBlock PRESOLVED OPTIMIZATION
	
	Call OpenForRead("SavedValues/DisableScript_Red1Burn4.txt");
	burn.BurnDirection[0] = file.GetLine().ToVariable();
	burn.BurnDirection[1] = file.GetLine().ToVariable();
	burn.BurnDirection[2] = file.GetLine().ToVariable();
	file.Close();
	
	deployableSat.Maneuver(burn);
	
	futureEpoch = blue[0].Epoch + rendezvousTime;
	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);
	
	red.Count -= 1;
	
	futureEpoch = blue[0].Epoch + preDeployWaitTime;
	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);
	
//Block PRESOLVED OPTIMIZATION
	If (doOptimizationAndSaveValues);
		
		opt.Reset(1);
		opt.AddStateVariableBlock(3, "dv1_", 0.001, -0.01, 0.01);
		opt.AddStateVariableBlock(3, "dv2_", 0.001, -0.01, 0.01);
		
		opt.AddConstraint("A", 42164, 42164, 1e1);
		opt.AddConstraint("E", 0, 1e-4);
		opt.AddConstraint("I", 0, 2, 1);
		opt.AddConstraint("lon", 277.2, 277.3, 1, 360);
		
		opt.SaveObjectToProcess(red[0]);
		
		opt.LoadEngine();
		While (opt.IsRunning());
			opt.UpdateStateVariables();
			opt.RestoreObjectsInProcess();
			
			burn.BurnDirection[0] = opt.GetStateVariableValue("dv1_1");
			burn.BurnDirection[1] = opt.GetStateVariableValue("dv1_2");
			burn.BurnDirection[2] = opt.GetStateVariableValue("dv1_3");
			red[0].Maneuver(burn);
			totalDV = burn.BurnDirection.Norm;
			
			futureEpoch = red[0].Epoch + TimeSpan.FromDays(7);
			WhileStepping red[0] to (red[0].Epoch == futureEpoch);
			End;
			
			burn.BurnDirection[0] = opt.GetStateVariableValue("dv2_1");
			burn.BurnDirection[1] = opt.GetStateVariableValue("dv2_2");
			burn.BurnDirection[2] = opt.GetStateVariableValue("dv2_3");
			red[0].Maneuver(burn);
			totalDV += burn.BurnDirection.Norm;
			
			kepState = red[0].GetKeplerianState();
			
			opt.SetConstraintValue("A", red[0].A);
			opt.SetConstraintValue("E", red[0].E);
			opt.SetConstraintValue("I", red[0].I);
			opt.SetConstraintValue("lon", red[0].Longitude);
			
			opt.Minimize(totalDV*1e-1);
			
			If (opt.OptimizationPhase == 1);
				Report opt.NominalEvaluationCount, opt.ObjectiveFunctionValue, opt.MaximumInfeasibility, opt.MaximumInfeasibilitySource;
			End;
		End;
		
		Report opt.ReturnString;
		opt.RestoreObjectsInProcess();
		
		burn.BurnDirection = opt.GetBestStateVariableValues()[0:2];
		
		Call OpenForWrite("SavedValues/DisableScript_Red1Burn5.txt");
		file.PutLine(burn.BurnDirection[0].ToString());
		file.PutLine(burn.BurnDirection[1].ToString());
		file.PutLine(burn.BurnDirection[2].ToString());
		file.Close();
	End;
//EndBlock PRESOLVED OPTIMIZATION
	
	Call OpenForRead("SavedValues/DisableScript_Red1Burn5.txt");
	burn.BurnDirection[0] = file.GetLine().ToVariable();
	burn.BurnDirection[1] = file.GetLine().ToVariable();
	burn.BurnDirection[2] = file.GetLine().ToVariable();
	file.Close();
	
	red[0].Maneuver(burn);
	
	futureEpoch = blue[0].Epoch + TimeSpan.FromDays(7);
	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);
	
EndProcedure;

]]></FreeFormScript>
      </FreeForm>
      <FreeForm enabled="true">
        <Label>Run things</Label>
        <Bookmarks />
        <Breakpoints />
        <FreeFormScript><![CDATA[
//Call BenignScript(red, blue);
Call ObservationScript(red, blue);
//Call DisableScript(red, blue);]]></FreeFormScript>
      </FreeForm>
    </ProjectCommands>
  </ProjectMissionSequence>
  <ProjectScript><![CDATA[
Global TimeSpan simStepSize = TimeSpan.FromSeconds(300);

Global TimeSpan aheadPredictTime = TimeSpan.FromHours(18);
Global TimeSpan aheadPredictUpdateInterval = TimeSpan.FromSeconds(300);
Global Constant Variable aheadPredictRangeUpdateLimit = 300;

Global TimeSpan simStartEpoch = TimeTools.ParseCalendarDate("Jun 09 2025 15:00:00.000", "TAI", "TAI", "MJD GSFC");

Global Variable colorRed1 = ColorTools.InterpolateColorHSV({ColorTools.White, ColorTools.Red, ColorTools.Black}, 0.5);
Global Variable colorRed2 = ColorTools.InterpolateColorHSV({ColorTools.White, ColorTools.Red, ColorTools.Black}, 0.75);
Global Variable colorRed3 = ColorTools.InterpolateColorHSV({ColorTools.White, ColorTools.Red, ColorTools.Black}, 0.25);
Global Variable colorRed4 = ColorTools.InterpolateColorHSV({ColorTools.White, ColorTools.Red, ColorTools.Black}, 0.1);
Global Variable colorBlue1 = ColorTools.DodgerBlue;

Global Variable radialViewTailLength = 3e2 * 300 / simStepSize.ToSeconds();

Global Variable doOptimizationAndSaveValues = 0;

Formation red;
Formation blue;

red.Count = 3;
blue.Count = 1;

red.ViewAsGroup = 0;
blue.ViewAsGroup = 0;

Global Array sensativePayloadUnitVectorBCS = {0, 0, 1};


Global GraphicsOverlay overlayRed1Future;
overlayRed1Future.SetReferenceObject(blue[0].ObjectId);
overlayRed1Future.DefaultColor = ColorTools.LightGray;

Global GraphicsOverlay overlayRed2Future;
overlayRed2Future.SetReferenceObject(blue[0].ObjectId);
overlayRed2Future.DefaultColor = ColorTools.LightGray;

Global GraphicsOverlay overlayRed3Future;
overlayRed3Future.SetReferenceObject(blue[0].ObjectId);
overlayRed3Future.DefaultColor = ColorTools.LightGray;


Global ViewWindow radialView;
radialView.CurrentViewpoint.ThreeDView.Radius = 2147.54485002776;
radialView.CurrentViewpoint.ThreeDView.RightAscension = 270;
radialView.CurrentViewpoint.ThreeDView.Declination = 0;
radialView.AddObject(red);
radialView.AddObject(blue);
radialView.AddObject(overlayRed1Future);
radialView.AddObject(overlayRed2Future);
radialView.AddObject(overlayRed3Future);
radialView.CurrentViewpoint.ThreeDView.Source = blue[0].ObjectId;
radialView.CurrentViewpoint.ThreeDView.Target = blue[0].ObjectId;
radialView.SetShowName(0, TypeOf(CelestialObject), 0);

Global ImpulsiveBurn burn;
burn.AttitudeSystem = 6;


Global FileInterface file;


Define Procedure OpenForRead(String filename);
	file.Filename = filename;
	file.ReadMode = 1;
	file.WriteMode = 0;
	file.Open();
EndProcedure;

Define Procedure OpenForWrite(String filename);
	file.Filename = filename;
	file.ReadMode = 0;
	file.WriteMode = 1;
	file.Open();
EndProcedure;

Global ViewFont vf;
vf.Size = 14;

// Set initial states
Variable baseRAAN = 40;
Variable baseI = 0.5;
blue[0].SetKeplerianState({42164,
                           1e-6,
                           baseI,
                           baseRAAN,
                           1,
                           1});
                           
blue[0].Epoch = simStartEpoch;
blue[0].Color = colorBlue1;
blue[0].BodyScale = 1000;
blue[0].DisplayName = "BlueSat";
blue[0].Propagator.StepSize = simStepSize;
blue[0].EulerAngles[1] = 90;
blue[0].TailLength = radialViewTailLength;
radialView.SetShowName(blue[0].ObjectId, 1);
radialView.SetObjectLabelFont(blue[0].ObjectId, vf);


Variable red1AngularSeparation = 2;
Variable red2AngularSeparation = 2.5;
Variable red2and3RadialSeparation = 60;
red[0].SetKeplerianState({42164,
                          1e-6,
                          baseI * 1.2,
                          baseRAAN - red1AngularSeparation,
                          1,
                          1});
red[1].SetKeplerianState({42164 - red2and3RadialSeparation,
                          1e-6,
                          baseI * 0.3,
                          baseRAAN - red2AngularSeparation * 1.7,
                          1,
                          1});
red[2].SetKeplerianState({42164 + red2and3RadialSeparation,
                          1e-6,
                          baseI * 0.3,
                          baseRAAN + red2AngularSeparation,
                          1,
                          1});
                          
red[0].Color = colorRed1;
red[1].Color = colorRed2;
red[2].Color = colorRed3;

Variable i;
For i = 0 to red.Count - 1;
	red[i].Epoch = simStartEpoch;
	red[i].BodyScale = 1000;
	red[i].DisplayName = "Red" + (i+1).ToString();
	red[i].TailLength = radialViewTailLength;
	radialView.SetShowName(red[i].ObjectId, 1);
	radialView.SetObjectLabelFont(red[i].ObjectId, vf);
End;


Global Array initialKepStateRed1 = red[0].GetKeplerianState();
Global TimeSpan simEpoch;

Global Variable rangeB1_R1;
Global Variable rangeB1_R2;
Global Variable rangeB1_R3;

Global PlotScatterSeries rangeAngleFromPayloadR1;
Global PlotScatterSeries rangeAngleFromPayloadR2;
Global PlotScatterSeries rangeAngleFromPayloadR3;

Global PlotScatterSeries rangeAngleFromPayloadR1CurrentLocation;
Global PlotScatterSeries rangeAngleFromPayloadR2CurrentLocation;
Global PlotScatterSeries rangeAngleFromPayloadR3CurrentLocation;

Global PlotScatterSeries rangeAngleFromPayloadR1Predict;
Global PlotScatterSeries rangeAngleFromPayloadR2Predict;
Global PlotScatterSeries rangeAngleFromPayloadR3Predict;

PlotScatterSeries rangeAngleKeepOutArea;
PlotScatterSeries rangeKeepOutArea;


// set up angle to sensative payload vs range plot
Global PlotWindow pwRange;
pwRange.SetBackgroundColorPalette("DarkGray");
pwRange.PlotTitle.Text = "Angle from Sensative Payload vs Range";
pwRange.PlotSubTitle.Visible = 0;
pwRange.HighQualityRendering = 1;
pwRange.PointsToUpdate = 5 * 300 / simStepSize.ToSeconds();
pwRange.MaxPoints = 3e2 * 300 / simStepSize.ToSeconds();
pwRange.UseMonitorMode = 1;
pwRange.AddSeries(rangeKeepOutArea);
pwRange.AddSeries(rangeAngleKeepOutArea);
pwRange.AddSeries(rangeAngleFromPayloadR1);
pwRange.AddSeries(rangeAngleFromPayloadR2);
pwRange.AddSeries(rangeAngleFromPayloadR3);
pwRange.AddSeries(rangeAngleFromPayloadR1CurrentLocation);
pwRange.AddSeries(rangeAngleFromPayloadR2CurrentLocation);
pwRange.AddSeries(rangeAngleFromPayloadR3CurrentLocation);
pwRange.AddSeries(rangeAngleFromPayloadR1Predict);
pwRange.AddSeries(rangeAngleFromPayloadR2Predict);
pwRange.AddSeries(rangeAngleFromPayloadR3Predict);
pwRange.XAxis.MaximumValue = 180;
pwRange.XAxis.MinimumValue = 0;
pwRange.XAxis.Title.Text = "Angle from Sensative Payload (deg)";
pwRange.YAxis.MaximumValue = 600;
pwRange.YAxis.MinimumValue = 0;
pwRange.YAxis.Title.Text = "Range (km)";
pwRange.Legend.Location = 3;

// rangeAngleFromPayloadXX
rangeAngleFromPayloadR1.Label = "Red1";
rangeAngleFromPayloadR2.Label = "Red2";
rangeAngleFromPayloadR3.Label = "Red3";

rangeAngleFromPayloadR1.LineColor = colorRed1;
rangeAngleFromPayloadR2.LineColor = colorRed2;
rangeAngleFromPayloadR3.LineColor = colorRed3;

rangeAngleFromPayloadR1.LineStyle = 0;
rangeAngleFromPayloadR2.LineStyle = 0;
rangeAngleFromPayloadR3.LineStyle = 0;

rangeAngleFromPayloadR1.LineWidth = 2;
rangeAngleFromPayloadR2.LineWidth = 2;
rangeAngleFromPayloadR3.LineWidth = 2;

// rangeAngleFromPayloadXXCurrentLocation
rangeAngleFromPayloadR1CurrentLocation.MarkersColor = colorRed1;
rangeAngleFromPayloadR2CurrentLocation.MarkersColor = colorRed2;
rangeAngleFromPayloadR3CurrentLocation.MarkersColor = colorRed3;

rangeAngleFromPayloadR1CurrentLocation.MarkersStyle = 1;
rangeAngleFromPayloadR2CurrentLocation.MarkersStyle = 1;
rangeAngleFromPayloadR3CurrentLocation.MarkersStyle = 1;

rangeAngleFromPayloadR1CurrentLocation.MarkersSize = 2;
rangeAngleFromPayloadR2CurrentLocation.MarkersSize = 2;
rangeAngleFromPayloadR3CurrentLocation.MarkersSize = 2;

rangeAngleFromPayloadR1CurrentLocation.MarkersVisible = 1;
rangeAngleFromPayloadR2CurrentLocation.MarkersVisible = 1;
rangeAngleFromPayloadR3CurrentLocation.MarkersVisible = 1;

rangeAngleFromPayloadR1CurrentLocation.LineVisible = 0;
rangeAngleFromPayloadR2CurrentLocation.LineVisible = 0;
rangeAngleFromPayloadR3CurrentLocation.LineVisible = 0;

rangeAngleFromPayloadR1CurrentLocation.ShowInLegend = 0;
rangeAngleFromPayloadR2CurrentLocation.ShowInLegend = 0;
rangeAngleFromPayloadR3CurrentLocation.ShowInLegend = 0;

rangeAngleFromPayloadR1CurrentLocation.AddPoints(0, 0);
rangeAngleFromPayloadR2CurrentLocation.AddPoints(0, 0);
rangeAngleFromPayloadR3CurrentLocation.AddPoints(0, 0);

// rangeAngleFromPayloadXXPredict
rangeAngleFromPayloadR1Predict.Label = "Red1 Predict";
rangeAngleFromPayloadR2Predict.Label = "Red2 Predict";
rangeAngleFromPayloadR3Predict.Label = "Red3 Predict";

rangeAngleFromPayloadR1Predict.LineColor = colorRed1;
rangeAngleFromPayloadR2Predict.LineColor = colorRed2;
rangeAngleFromPayloadR3Predict.LineColor = colorRed3;

rangeAngleFromPayloadR1Predict.LineStyle = 2;
rangeAngleFromPayloadR2Predict.LineStyle = 2;
rangeAngleFromPayloadR3Predict.LineStyle = 2;

rangeAngleFromPayloadR1Predict.LineWidth = 1;
rangeAngleFromPayloadR2Predict.LineWidth = 1;
rangeAngleFromPayloadR3Predict.LineWidth = 1;

// rangeAngleKeepOutArea
rangeAngleKeepOutArea.LineColor = ColorTools.Yellow;
rangeAngleKeepOutArea.LineWidth = 3;
rangeAngleKeepOutArea.LineStyle = 0;
rangeAngleKeepOutArea.Label = "Payload Keep Out Zone";
rangeAngleKeepOutArea.AddPoints({0, 0, 45, 90}, {0, 80, 80, 0});
rangeAngleKeepOutArea.AddPoints(rangeAngleKeepOutArea.Data[0,:]);

// rangeKeepOutArea
rangeKeepOutArea.LineColor = ColorTools.Orange;
rangeKeepOutArea.LineWidth = 3;
rangeKeepOutArea.LineStyle = 0;
rangeKeepOutArea.Label = "Range Keep Out Zone";
rangeKeepOutArea.AddPoints({0, 0, 180, 180}, {0, 30, 30, 0});
rangeKeepOutArea.AddPoints(rangeKeepOutArea.Data[0,:]);


// Set up longitude radius plot

Global PlotScatterSeries radiusLongitudeB1;
Global PlotScatterSeries radiusLongitudeR1;
Global PlotScatterSeries radiusLongitudeR2;
Global PlotScatterSeries radiusLongitudeR3;

Global PlotScatterSeries radiusLongitudeB1CurrentLocation;
Global PlotScatterSeries radiusLongitudeR1CurrentLocation;
Global PlotScatterSeries radiusLongitudeR2CurrentLocation;
Global PlotScatterSeries radiusLongitudeR3CurrentLocation;


Global PlotWindow pwRadiusLongitude;
pwRadiusLongitude.SetBackgroundColorPalette("DarkGray");
pwRadiusLongitude.PlotTitle.Text = "Longitude vs Radius";
pwRadiusLongitude.PlotSubTitle.Visible = 0;
pwRadiusLongitude.HighQualityRendering = 1;
pwRadiusLongitude.PointsToUpdate = 5 * 300 / simStepSize.ToSeconds();
//pwRadiusLongitude.MaxPoints = 1e3 * 300 / simStepSize.ToSeconds();
pwRadiusLongitude.MaxPoints = 1e3 * 300 / simStepSize.ToSeconds();
pwRadiusLongitude.UseMonitorMode = 1;
pwRadiusLongitude.AddSeries(radiusLongitudeB1);
pwRadiusLongitude.AddSeries(radiusLongitudeR1);
pwRadiusLongitude.AddSeries(radiusLongitudeR2);
pwRadiusLongitude.AddSeries(radiusLongitudeR3);
pwRadiusLongitude.AddSeries(radiusLongitudeB1CurrentLocation);
pwRadiusLongitude.AddSeries(radiusLongitudeR1CurrentLocation);
pwRadiusLongitude.AddSeries(radiusLongitudeR2CurrentLocation);
pwRadiusLongitude.AddSeries(radiusLongitudeR3CurrentLocation);
pwRadiusLongitude.XAxis.MaximumValue = blue[0].Longitude + 3;
pwRadiusLongitude.XAxis.MinimumValue = blue[0].Longitude - 3;
pwRadiusLongitude.XAxis.Title.Text = "Longitude (deg)";
pwRadiusLongitude.YAxis.MaximumValue = 42250;
pwRadiusLongitude.YAxis.MinimumValue = 42050;
pwRadiusLongitude.YAxis.Title.Text = "Radius (km)";

// radiusLongitudeXXCurrentLocation
radiusLongitudeB1CurrentLocation.MarkersColor = colorBlue1;
radiusLongitudeR1CurrentLocation.MarkersColor = colorRed1;
radiusLongitudeR2CurrentLocation.MarkersColor = colorRed2;
radiusLongitudeR3CurrentLocation.MarkersColor = colorRed3;

radiusLongitudeB1CurrentLocation.MarkersStyle = 1;
radiusLongitudeR1CurrentLocation.MarkersStyle = 1;
radiusLongitudeR2CurrentLocation.MarkersStyle = 1;
radiusLongitudeR3CurrentLocation.MarkersStyle = 1;

radiusLongitudeB1CurrentLocation.MarkersSize = 2;
radiusLongitudeR1CurrentLocation.MarkersSize = 2;
radiusLongitudeR2CurrentLocation.MarkersSize = 2;
radiusLongitudeR3CurrentLocation.MarkersSize = 2;

radiusLongitudeB1CurrentLocation.MarkersVisible = 1;
radiusLongitudeR1CurrentLocation.MarkersVisible = 1;
radiusLongitudeR2CurrentLocation.MarkersVisible = 1;
radiusLongitudeR3CurrentLocation.MarkersVisible = 1;

radiusLongitudeB1CurrentLocation.LineVisible = 0;
radiusLongitudeR1CurrentLocation.LineVisible = 0;
radiusLongitudeR2CurrentLocation.LineVisible = 0;
radiusLongitudeR3CurrentLocation.LineVisible = 0;

radiusLongitudeB1CurrentLocation.ShowInLegend = 0;
radiusLongitudeR1CurrentLocation.ShowInLegend = 0;
radiusLongitudeR2CurrentLocation.ShowInLegend = 0;
radiusLongitudeR3CurrentLocation.ShowInLegend = 0;

radiusLongitudeB1CurrentLocation.AddPoints(0, 0);
radiusLongitudeR1CurrentLocation.AddPoints(0, 0);
radiusLongitudeR2CurrentLocation.AddPoints(0, 0);
radiusLongitudeR3CurrentLocation.AddPoints(0, 0);

// radiusLongitude
radiusLongitudeB1.Label = "BlueSat";
radiusLongitudeR1.Label = "Red1";
radiusLongitudeR2.Label = "Red2";
radiusLongitudeR3.Label = "Red3";

radiusLongitudeB1.LineColor = colorBlue1;
radiusLongitudeR1.LineColor = colorRed1;
radiusLongitudeR2.LineColor = colorRed2;
radiusLongitudeR3.LineColor = colorRed3;

radiusLongitudeB1.LineStyle = 0;
radiusLongitudeR1.LineStyle = 0;
radiusLongitudeR2.LineStyle = 0;
radiusLongitudeR3.LineStyle = 0;

radiusLongitudeB1.LineWidth = 2;
radiusLongitudeR1.LineWidth = 2;
radiusLongitudeR2.LineWidth = 2;
radiusLongitudeR3.LineWidth = 2;

Call AddVerticalLine(
	pwRadiusLongitude,
	pwRadiusLongitude.XAxis.MinimumValue + (pwRadiusLongitude.XAxis.MaximumValue - pwRadiusLongitude.XAxis.MinimumValue) * 0.88,
	{pwRadiusLongitude.YAxis.MinimumValue + (pwRadiusLongitude.YAxis.MaximumValue - pwRadiusLongitude.YAxis.MinimumValue) * 0.17, pwRadiusLongitude.YAxis.MinimumValue + 10},
	2,
	ColorTools.Green,
	0,
	"");
Call AddFloatingLabelToPlot(
	pwRadiusLongitude,
	pwRadiusLongitude.XAxis.MinimumValue + (pwRadiusLongitude.XAxis.MaximumValue - pwRadiusLongitude.XAxis.MinimumValue) * 0.88,
	pwRadiusLongitude.YAxis.MinimumValue + (pwRadiusLongitude.YAxis.MaximumValue - pwRadiusLongitude.YAxis.MinimumValue) * 0.15,
	ColorTools.Green,
	ColorTools.LightGray,
	"Candara",
	16,
	"To Earth");
Call AddSinglePointToPlot(
	pwRadiusLongitude,
	pwRadiusLongitude.XAxis.MinimumValue + (pwRadiusLongitude.XAxis.MaximumValue - pwRadiusLongitude.XAxis.MinimumValue) * 0.88,
	pwRadiusLongitude.YAxis.MinimumValue + 10,
	5,
	3,
	ColorTools.Green,
	"");






OutputLayout.SetWindowFrameVisibility({radialView.ID, pwRadiusLongitude.ID, pwRange.ID}, 0);
OutputLayout.SetWindowPosition(pwRadiusLongitude.ID, 1, 0, 1, 0);
OutputLayout.SetWindowSize(pwRadiusLongitude.ID, 1, 0.4, 1, 0.5);
OutputLayout.SetWindowPosition(pwRange.ID, 1, 0, 1, 0.5);
OutputLayout.SetWindowSize(pwRange.ID, 1, 0.4, 1, 0.5);
OutputLayout.SetWindowPosition(radialView.ID, 1, 0.4, 1, 0);
OutputLayout.SetWindowSize(radialView.ID, 1, 0.6, 1, 1);
OutputLayout.ApplyUpdates();


Define Procedure ComputePredict(Spacecraft primarySC, Spacecraft secondarySC, TimeSpan predictionDuration, GraphicsOverlay go, PlotScatterSeries angleRangeSeries, Variable justEraseOverlay);
	Array positionBCS;
	Variable i;
	
	
	Matrix futureStateMJ2000 = Matrix.Empty;
	futureStateMJ2000.ColumnCount = 3;
	
	TimeSpan currentStep = TimeSpan.Zero();
	
	// Reset the GraphicsOverlay
	go.ClearOverlayElements();
	angleRangeSeries.ClearPoints();
	
	If (justEraseOverlay);
		ExitProcedure;
	End;
	
	Save primarySC;
	Save secondarySC;
	primarySC.Propagator.StepSize = TimeSpan.FromSeconds(300);
	
    // Compute the future path of the secondary with respect to the primary
	TimeSpan epochToStepTo = primarySC.Epoch + predictionDuration;
	WhileStepping primarySC to (primarySC.Epoch == epochToStepTo);
		secondarySC.StepToEpoch(primarySC.Epoch);
		
		positionBCS = AttitudeConvert(0, 3, primarySC, secondarySC.Position - primarySC.Position);
		
		go.AddOverlayElement(positionBCS[0], positionBCS[1], positionBCS[2]);
		
		angleRangeSeries.AddPoints(deg(acos(positionBCS.Normalized.DotProduct(sensativePayloadUnitVectorBCS.Normalized))), positionBCS.Norm);
	End;

	
	Restore primarySC;
	Restore secondarySC;
	
EndProcedure;


Define Procedure ComputeStationKeepingManeuver(Optimizer opt, Spacecraft sc, Variable longitude);
	TimeSpan initialEpoch;
	opt.Reset(1);
	opt.AddStateVariableBlock(3, "dv", 0.0001, -0.001, 0.001, 1, 1e-6);
	
	opt.SaveObjectToProcess(sc);
	
	opt.MaximumNominalEvaluationCount = 50;
	opt.LoadEngine();
	While (opt.IsRunning());
		opt.UpdateStateVariables();
		opt.RestoreObjectsInProcess();
		burn.BurnDirection = opt.GetStateVariableValues();
		
		sc.Maneuver(burn);
		
		initialEpoch = sc.Epoch;
		While (abs(sc.Longitude - longitude) < 0.05);
			sc.Step(TimeSpan.FromSeconds(30));
		End;
		
		opt.Maximize((sc.Epoch - initialEpoch).ToHours());
		
		If (opt.OptimizationPhase == 1);
			Report opt.NominalEvaluationCount, opt.ObjectiveFunctionValue, burn.BurnDirection.Norm, opt.MaximumInfeasibility, opt.MaximumInfeasibilitySource;
		End;
	End;
	
	Report opt.ReturnString;
	opt.RestoreObjectsInProcess();
EndProcedure;

Define Procedure ComputeRangeAndAngleFromPayload(Spacecraft blue, Spacecraft red, Variable range, Variable angle);
	Array positionBCS;
	
	positionBCS = AttitudeConvert(0, 3, blue, red.Position - blue.Position);
	range = positionBCS.Norm;
	angle = deg(acos(positionBCS.Normalized.DotProduct(sensativePayloadUnitVectorBCS.Normalized)));
EndProcedure;

Define Procedure AdvanceSimToFutureEpoch(Formation red, Formation blue, TimeSpan futureEpoch);
	TimeSpan timeSinceAheadPredictUpdate = TimeSpan.Zero();
	
	Variable angle;
	
	WhileStepping blue[0] to (blue[0].Epoch == futureEpoch);
		pwRange.BeginBatchUpdate();
		red.StepToEpoch(blue[0].Epoch);
		simEpoch = blue[0].Epoch;
	
		// update angle vs range data
		Call ComputeRangeAndAngleFromPayload(blue[0], red[0], rangeB1_R1, angle);
		rangeAngleFromPayloadR1.AddPoints(angle, rangeB1_R1);
		rangeAngleFromPayloadR1CurrentLocation.Data[0, 0:1] = rangeAngleFromPayloadR1.Data[rangeAngleFromPayloadR1.Data.RowCount - 1, 0:1];
		
		Call ComputeRangeAndAngleFromPayload(blue[0], red[1], rangeB1_R2, angle);
		rangeAngleFromPayloadR2.AddPoints(angle, rangeB1_R2);
		rangeAngleFromPayloadR2CurrentLocation.Data[0, 0:1] = rangeAngleFromPayloadR2.Data[rangeAngleFromPayloadR2.Data.RowCount - 1, 0:1];
		
		Call ComputeRangeAndAngleFromPayload(blue[0], red[2], rangeB1_R3, angle);
		rangeAngleFromPayloadR3.AddPoints(angle, rangeB1_R3);
		rangeAngleFromPayloadR3CurrentLocation.Data[0, 0:1] = rangeAngleFromPayloadR3.Data[rangeAngleFromPayloadR3.Data.RowCount - 1, 0:1];

		// update longitude vs radius data
		radiusLongitudeB1.AddPoints(blue[0].Longitude, blue[0].Radius);
		radiusLongitudeR1.AddPoints(red[0].Longitude, red[0].Radius);
		radiusLongitudeR2.AddPoints(red[1].Longitude, red[1].Radius);
		radiusLongitudeR3.AddPoints(red[2].Longitude, red[2].Radius);
		radiusLongitudeB1CurrentLocation.Data[0, 0:1] = radiusLongitudeB1.Data[radiusLongitudeB1.Data.RowCount - 1, 0:1];
		radiusLongitudeR1CurrentLocation.Data[0, 0:1] = radiusLongitudeR1.Data[radiusLongitudeR1.Data.RowCount - 1, 0:1];
		radiusLongitudeR2CurrentLocation.Data[0, 0:1] = radiusLongitudeR2.Data[radiusLongitudeR2.Data.RowCount - 1, 0:1];
		radiusLongitudeR3CurrentLocation.Data[0, 0:1] = radiusLongitudeR3.Data[radiusLongitudeR3.Data.RowCount - 1, 0:1];
		
		// update predict data
		timeSinceAheadPredictUpdate += blue[0].Propagator.StepSize;
		If (timeSinceAheadPredictUpdate > aheadPredictUpdateInterval);
			Call ComputePredict(blue[0], red[0], aheadPredictTime, overlayRed1Future, rangeAngleFromPayloadR1Predict, rangeB1_R1 > aheadPredictRangeUpdateLimit);
			Call ComputePredict(blue[0], red[1], aheadPredictTime, overlayRed2Future, rangeAngleFromPayloadR2Predict, rangeB1_R2 > aheadPredictRangeUpdateLimit);
			Call ComputePredict(blue[0], red[2], aheadPredictTime, overlayRed3Future, rangeAngleFromPayloadR3Predict, rangeB1_R3 > aheadPredictRangeUpdateLimit);
			timeSinceAheadPredictUpdate = TimeSpan.Zero;
		End;
		
		
		pwRange.EndBatchUpdate();
		pwRadiusLongitude.Update();
		radialView.Update();
	End;
EndProcedure;


Define Procedure BenignScript(Formation red, Formation blue);
	Optimizer opt;
	TimeSpan initialEpoch;
	
	TimeSpan futureEpoch = blue[0].Epoch + TimeSpan.FromDays(1);
	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);
	
//Block PRESOLVED OPTIMIZATION
	If (doOptimizationAndSaveValues);
		Call ComputeStationKeepingManeuver(opt, blue[0], 279.25);
		burn.BurnDirection = opt.GetBestStateVariableValues();
		
		Call OpenForWrite("SavedValues/BenignScript_Blue1SK1.txt");
		file.PutLine(burn.BurnDirection[0].ToString());
		file.PutLine(burn.BurnDirection[1].ToString());
		file.PutLine(burn.BurnDirection[2].ToString());
		file.Close();
	End;
//EndBlock PRESOLVED OPTIMIZATION

	Call OpenForRead("SavedValues/BenignScript_Blue1SK1.txt");
	burn.BurnDirection[0] = file.GetLine().ToVariable();
	burn.BurnDirection[1] = file.GetLine().ToVariable();
	burn.BurnDirection[2] = file.GetLine().ToVariable();
	file.Close();
	
	blue[0].Maneuver(burn);
	
	futureEpoch = blue[0].Epoch + TimeSpan.FromDays(1);
	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);
	
	//Block PRESOLVED OPTIMIZATION
	If (doOptimizationAndSaveValues);
		Call ComputeStationKeepingManeuver(opt, red[0], 277.3);
		burn.BurnDirection = opt.GetBestStateVariableValues();
		
		Call OpenForWrite("SavedValues/BenignScript_Red1SK1.txt");
		file.PutLine(burn.BurnDirection[0].ToString());
		file.PutLine(burn.BurnDirection[1].ToString());
		file.PutLine(burn.BurnDirection[2].ToString());
		file.Close();
	End;
//EndBlock PRESOLVED OPTIMIZATION

	Call OpenForRead("SavedValues/BenignScript_Red1SK1.txt");
	burn.BurnDirection[0] = file.GetLine().ToVariable();
	burn.BurnDirection[1] = file.GetLine().ToVariable();
	burn.BurnDirection[2] = file.GetLine().ToVariable();
	file.Close();
	
	red[0].Maneuver(burn);
	
	futureEpoch = blue[0].Epoch + TimeSpan.FromDays(7);
	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);
	
EndProcedure;


Define Procedure ObservationScript(Formation red, Formation blue);
	
	Array relativePos;
	Array relativeVel;
	Array desiredRelativePosLVC;
	Variable relativeStateObjective;
	Optimizer opt;
	NloptOptions nlopt;
	TimeSpan initialEpoch;
	Variable maxDistance;
	Variable minDistance;
	Variable minAngle;
	Variable distance;
	Variable angle;
	
	TimeSpan futureEpoch = blue[0].Epoch + TimeSpan.FromDays(1);
	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);
	
//Block PRESOLVED OPTIMIZATION
	If (doOptimizationAndSaveValues);
		Call ComputeStationKeepingManeuver(opt, blue[0], 279.25);
		burn.BurnDirection = opt.GetBestStateVariableValues();
		
		Call OpenForWrite("SavedValues/ObservationScript_Blue1SK1.txt");
		file.PutLine(burn.BurnDirection[0].ToString());
		file.PutLine(burn.BurnDirection[1].ToString());
		file.PutLine(burn.BurnDirection[2].ToString());
		file.Close();
	End;
//EndBlock PRESOLVED OPTIMIZATION

	Call OpenForRead("SavedValues/ObservationScript_Blue1SK1.txt");
	burn.BurnDirection[0] = file.GetLine().ToVariable();
	burn.BurnDirection[1] = file.GetLine().ToVariable();
	burn.BurnDirection[2] = file.GetLine().ToVariable();
	file.Close();
	
	blue[0].Maneuver(burn);

//Block PRESOLVED OPTIMIZATION
	If (doOptimizationAndSaveValues);
		desiredRelativePosLVC = {0, 0, 60};

		opt.Reset(1);
		opt.AddStateVariableBlock(3, "dv", 0.001, -0.01, 0.01);
		opt.AddStateVariable("days", 7, 6.7, 7.3);
		opt.AddConstraintBlock(3, "relativePos", 0, 0, 100);
		opt.AddConstraint("crossTrackVel", 0, 0);
		
		opt.SaveObjectToProcess(red[0]);
		opt.SaveObjectToProcess(blue[0]);
		
		opt.LoadEngine();
		While (opt.IsRunning());
			opt.UpdateStateVariables();
			opt.RestoreObjectsInProcess();
			burn.BurnDirection = opt.GetStateVariableValues()[0:2];
			
			red[0].Maneuver(burn);
			
			futureEpoch = blue[0].Epoch + TimeSpan.FromDays(opt.GetStateVariableValue("days"));
			WhileStepping blue[0] to (blue[0].Epoch == futureEpoch);
				red[0].StepToEpoch(blue[0].Epoch);
			End;
			
			relativePos = RelativeMotionUtilities.ConvertRelativePosition(0, 6, red[0], blue[0].Position - red[0].Position);
			relativeVel = RelativeMotionUtilities.ConvertRelativeVelocity(0, 6, red[0], blue[0].GetCartesianState() - red[0].GetCartesianState());
//			relativePos[2] = desiredRelativePosLVC[2]; // we don't care about cross track so zero it out
			opt.SetConstraintValues({desiredRelativePosLVC - relativePos, relativeVel[2]});
			
			opt.Minimize(burn.BurnDirection.Norm);
			
			If (opt.OptimizationPhase == 1);
				Report opt.NominalEvaluationCount, opt.ObjectiveFunctionValue, opt.MaximumInfeasibility, opt.MaximumInfeasibilitySource;
			End;
		End;
		
		Report opt.ReturnString;
		opt.RestoreObjectsInProcess();
		
		burn.BurnDirection = opt.GetBestStateVariableValues()[0:2];
		
		Call OpenForWrite("SavedValues/ObservationScript_Red1Burn1.txt");
		file.PutLine(burn.BurnDirection[0].ToString());
		file.PutLine(burn.BurnDirection[1].ToString());
		file.PutLine(burn.BurnDirection[2].ToString());
		file.PutLine(opt.GetBestStateVariableValue("days").ToString());
		file.Close();
	End;
//EndBlock PRESOLVED OPTIMIZATION
	
	Call OpenForRead("SavedValues/ObservationScript_Red1Burn1.txt");
	burn.BurnDirection[0] = file.GetLine().ToVariable();
	burn.BurnDirection[1] = file.GetLine().ToVariable();
	burn.BurnDirection[2] = file.GetLine().ToVariable();
	futureEpoch = blue[0].Epoch + TimeSpan.FromDays(file.GetLine().ToVariable());
	file.Close();

	red[0].Maneuver(burn);

	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);
	

//Block PRESOLVED OPTIMIZATION
	If (doOptimizationAndSaveValues);
		desiredRelativePosLVC = RelativeMotionUtilities.ConvertRelativePosition(0, 6, red[0], blue[0].Position - red[0].Position);

		opt.Reset(1);
		opt.MaximumNominalEvaluationCount = 1800;
		opt.AddStateVariableBlock(3, "dv", 0.001, -0.01, 0.01);
		opt.AddConstraint("minAngle", -1e-20, 15);
		opt.AddConstraint("minDistance", 50, 1e20);
		opt.AddConstraint("maxDistance", -1e20, 80);
		
		opt.SaveObjectToProcess(red[0]);
		opt.SaveObjectToProcess(blue[0]);
		
		nlopt.AlgorithmToUse = 38;
		nlopt.SubsidiaryAlgorithmToUse = 40;
		
		opt.LoadEngine();
		While (opt.IsRunning());
			opt.UpdateStateVariables();
			opt.RestoreObjectsInProcess();
			burn.BurnDirection = opt.GetStateVariableValues();
			
			red[0].Maneuver(burn);
			
			futureEpoch = blue[0].Epoch + TimeSpan.FromDays(1);
			Call ComputeRangeAndAngleFromPayload(blue[0], red[0], distance, angle);
			minDistance = distance;
			maxDistance = distance;
			minAngle = angle;
			WhileStepping blue[0] to (blue[0].Epoch == futureEpoch);
				red[0].StepToEpoch(blue[0].Epoch);
				Call ComputeRangeAndAngleFromPayload(blue[0], red[0], distance, angle);
				If (distance < minDistance);
					minDistance = distance;
				End;
				If (distance > maxDistance);
					maxDistance = distance;
				End;
				If (angle < minAngle);
					minAngle = angle;
				End;
			End;
			
			opt.SetConstraintValue("minAngle", minAngle);
			opt.SetConstraintValue("minDistance", minDistance);
			opt.SetConstraintValue("maxDistance", maxDistance);
			
			opt.Minimize(burn.BurnDirection.Norm * 1e0);
						
			If (opt.OptimizationPhase == 1);
				Report opt.NominalEvaluationCount, burn.BurnDirection.Norm, minAngle, minDistance, maxDistance, opt.MaximumInfeasibility, opt.MaximumInfeasibilitySource;
			End;
			
//			futureEpoch = blue[0].Epoch + TimeSpan.FromDays(0.25);
//			WhileStepping blue[0] to (blue[0].Epoch == futureEpoch);
//				red[0].StepToEpoch(blue[0].Epoch);
//			End;
//			
//			relativeStateObjective = abs((blue[0].Position - red[0].Position).Norm - desiredRelativePosLVC.Norm());
//			
//			futureEpoch = blue[0].Epoch + TimeSpan.FromDays(0.25);
//			WhileStepping blue[0] to (blue[0].Epoch == futureEpoch);
//				red[0].StepToEpoch(blue[0].Epoch);
//			End;
//			
//			relativePos = RelativeMotionUtilities.ConvertRelativePosition(0, 6, red[0], blue[0].Position - red[0].Position);
//			relativeStateObjective += (-desiredRelativePosLVC - relativePos).Norm;
//			
//			futureEpoch = blue[0].Epoch + TimeSpan.FromDays(0.25);
//			WhileStepping blue[0] to (blue[0].Epoch == futureEpoch);
//				red[0].StepToEpoch(blue[0].Epoch);
//			End;
//			
//			relativeStateObjective += abs((blue[0].Position - red[0].Position).Norm - desiredRelativePosLVC.Norm());
//			
//			futureEpoch = blue[0].Epoch + TimeSpan.FromDays(0.25);
//			WhileStepping blue[0] to (blue[0].Epoch == futureEpoch);
//				red[0].StepToEpoch(blue[0].Epoch);
//			End;
//			
//			relativePos = RelativeMotionUtilities.ConvertRelativePosition(0, 6, red[0], blue[0].Position - red[0].Position);
//			relativeStateObjective += (desiredRelativePosLVC - relativePos).Norm;
//			
//			opt.Minimize(burn.BurnDirection.Norm * 1e2 + relativeStateObjective*1e0);
//			
//			If (opt.OptimizationPhase == 1);
//				Report opt.NominalEvaluationCount, burn.BurnDirection.Norm, relativeStateObjective, opt.MaximumInfeasibility, opt.MaximumInfeasibilitySource;
//			End;
		End;
		
		Report opt.ReturnString;
		opt.RestoreObjectsInProcess();
		
		burn.BurnDirection = opt.GetBestStateVariableValues();
		
		Call OpenForWrite("SavedValues/ObservationScript_Red1Burn2.txt");
		file.PutLine(burn.BurnDirection[0].ToString());
		file.PutLine(burn.BurnDirection[1].ToString());
		file.PutLine(burn.BurnDirection[2].ToString());
		file.Close();
	End;
//EndBlock PRESOLVED OPTIMIZATION
	
	Call OpenForRead("SavedValues/ObservationScript_Red1Burn2.txt");
	burn.BurnDirection[0] = file.GetLine().ToVariable();
	burn.BurnDirection[1] = file.GetLine().ToVariable();
	burn.BurnDirection[2] = file.GetLine().ToVariable();
	file.Close();
	
	red[0].Maneuver(burn);
	
	futureEpoch = blue[0].Epoch + TimeSpan.FromDays(1);
	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);
	
	burn.BurnDirection = -{    0.000145506,       -0.000805460,       -0.000000254};
	red[0].Maneuver(burn);
	
	futureEpoch = blue[0].Epoch + TimeSpan.FromDays(7);
	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);
	
EndProcedure;


Define Procedure DisableScript(Formation red, Formation blue);
	
	Array relativePos;
	Array desiredRelativePosLVC;
	Optimizer opt;
	Variable relativeStateObjective;
	NloptOptions nlopt;
	Array kepState;
	Variable totalDV;
	TimeSpan initialEpoch;
	
	TimeSpan futureEpoch = blue[0].Epoch + TimeSpan.FromDays(1);
	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);
	
//Block PRESOLVED OPTIMIZATION
	If (doOptimizationAndSaveValues);
		Call ComputeStationKeepingManeuver(opt, blue[0], 279.25);
		burn.BurnDirection = opt.GetBestStateVariableValues();
		
		Call OpenForWrite("SavedValues/DisableScript_Blue1SK1.txt");
		file.PutLine(burn.BurnDirection[0].ToString());
		file.PutLine(burn.BurnDirection[1].ToString());
		file.PutLine(burn.BurnDirection[2].ToString());
		file.Close();
	End;
//EndBlock PRESOLVED OPTIMIZATION

	Call OpenForRead("SavedValues/DisableScript_Blue1SK1.txt");
	burn.BurnDirection[0] = file.GetLine().ToVariable();
	burn.BurnDirection[1] = file.GetLine().ToVariable();
	burn.BurnDirection[2] = file.GetLine().ToVariable();
	file.Close();
	
	blue[0].Maneuver(burn);
	
//Block PRESOLVED OPTIMIZATION
	If (doOptimizationAndSaveValues);
		desiredRelativePosLVC = {0, 4, 2};
		
		opt.Reset(1);
		opt.AddStateVariableBlock(3, "dv", 0.001, -0.01, 0.01);
		opt.AddConstraintBlock(3, "relativePos", 0, 0);
		
		opt.SaveObjectToProcess(red[0]);
		opt.SaveObjectToProcess(blue[0]);
		
		opt.LoadEngine();
		While (opt.IsRunning());
			opt.UpdateStateVariables();
			opt.RestoreObjectsInProcess();
			burn.BurnDirection = opt.GetStateVariableValues();
			
			red[0].Maneuver(burn);
			
			futureEpoch = blue[0].Epoch + TimeSpan.FromDays(4);
			WhileStepping blue[0] to (blue[0].Epoch == futureEpoch);
				red[0].StepToEpoch(blue[0].Epoch);
			End;
			
			relativePos = RelativeMotionUtilities.ConvertRelativePosition(0, 6, red[0], blue[0].Position - red[0].Position);
			relativePos[2] = desiredRelativePosLVC[2]; // we don't care about cross track so zero it out
			opt.SetConstraintValues(desiredRelativePosLVC - relativePos);
			
			opt.Minimize(burn.BurnDirection.Norm);
			
			If (opt.OptimizationPhase == 1);
				Report opt.NominalEvaluationCount, opt.ObjectiveFunctionValue, opt.MaximumInfeasibility, opt.MaximumInfeasibilitySource;
			End;
		End;
		
		Report opt.ReturnString;
		opt.RestoreObjectsInProcess();
		
		burn.BurnDirection = opt.GetBestStateVariableValues();
		
		Call OpenForWrite("SavedValues/DisableScript_Red1Burn1.txt");
		file.PutLine(burn.BurnDirection[0].ToString());
		file.PutLine(burn.BurnDirection[1].ToString());
		file.PutLine(burn.BurnDirection[2].ToString());
		file.Close();
	End;
//EndBlock PRESOLVED OPTIMIZATION

	Call OpenForRead("SavedValues/DisableScript_Red1Burn1.txt");
	burn.BurnDirection[0] = file.GetLine().ToVariable();
	burn.BurnDirection[1] = file.GetLine().ToVariable();
	burn.BurnDirection[2] = file.GetLine().ToVariable();
	file.Close();

	red[0].Maneuver(burn);

	futureEpoch = blue[0].Epoch + TimeSpan.FromDays(4);
	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);

//Block PRESOLVED OPTIMIZATION
	If (doOptimizationAndSaveValues);
		desiredRelativePosLVC = RelativeMotionUtilities.ConvertRelativePosition(0, 6, red[0], blue[0].Position - red[0].Position);
		
		opt.Reset(1);
		opt.MaximumNominalEvaluationCount = 800;
		opt.AddStateVariableBlock(3, "dv", 0.001, -0.01, 0.01);
		
		opt.SaveObjectToProcess(red[0]);
		opt.SaveObjectToProcess(blue[0]);
		
		nlopt.AlgorithmToUse = 38;
		nlopt.SubsidiaryAlgorithmToUse = 40;
		
		opt.LoadEngine(nlopt);
		While (opt.IsRunning());
			opt.UpdateStateVariables();
			opt.RestoreObjectsInProcess();
			burn.BurnDirection = opt.GetStateVariableValues();
			
			red[0].Maneuver(burn);
			
			futureEpoch = blue[0].Epoch + TimeSpan.FromDays(0.5);
			WhileStepping blue[0] to (blue[0].Epoch == futureEpoch);
				red[0].StepToEpoch(blue[0].Epoch);
			End;
			
			relativePos = RelativeMotionUtilities.ConvertRelativePosition(0, 6, red[0], blue[0].Position - red[0].Position);
			relativeStateObjective = (-desiredRelativePosLVC - relativePos).Norm;
			
			futureEpoch = blue[0].Epoch + TimeSpan.FromDays(0.5);
			WhileStepping blue[0] to (blue[0].Epoch == futureEpoch);
				red[0].StepToEpoch(blue[0].Epoch);
			End;
			
			relativePos = RelativeMotionUtilities.ConvertRelativePosition(0, 6, red[0], blue[0].Position - red[0].Position);
			relativeStateObjective += (desiredRelativePosLVC - relativePos).Norm;
			
			opt.Minimize(burn.BurnDirection.Norm * 1e3 + relativeStateObjective*1e0);
			
			If (opt.OptimizationPhase == 1);
				Report opt.NominalEvaluationCount, opt.ObjectiveFunctionValue, opt.MaximumInfeasibility, opt.MaximumInfeasibilitySource;
			End;
		End;
		
		Report opt.ReturnString;
		opt.RestoreObjectsInProcess();
		
		burn.BurnDirection = opt.GetBestStateVariableValues();
		
		Call OpenForWrite("SavedValues/DisableScript_Red1Burn2.txt");
		file.PutLine(burn.BurnDirection[0].ToString());
		file.PutLine(burn.BurnDirection[1].ToString());
		file.PutLine(burn.BurnDirection[2].ToString());
		file.Close();
	End;

//EndBlock PRESOLVED OPTIMIZATION

	Call OpenForRead("SavedValues/DisableScript_Red1Burn2.txt");
	burn.BurnDirection[0] = file.GetLine().ToVariable();
	burn.BurnDirection[1] = file.GetLine().ToVariable();
	burn.BurnDirection[2] = file.GetLine().ToVariable();
	file.Close();


	red[0].Maneuver(burn);
	
	TimeSpan preDeployWaitTime = TimeSpan.FromDays(0.1);
	TimeSpan rendezvousTime = TimeSpan.FromDays(0.3);
	TimeSpan killOperationTime = TimeSpan.FromDays(0.2);
	
	futureEpoch = blue[0].Epoch + preDeployWaitTime;
	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);
	
	// Deploy inspector from Red 1
	red.Count += 1;
	Alias deployableSat = red[red.Count - 1];
	deployableSat.BodyScale = 200;
	deployableSat.DisplayName = "RedSat" + red.Count.ToString();
	deployableSat.Color = colorRed4;
	deployableSat.TailLength = radialViewTailLength/4;
	radialView.SetShowName(deployableSat.ObjectId, 1);
	radialView.SetObjectLabelFont(deployableSat.ObjectId, vf);
	
	deployableSat.Epoch = red[0].Epoch;
	deployableSat.SetCartesianState(red[0].GetCartesianState());

//Block PRESOLVED OPTIMIZATION
	If (doOptimizationAndSaveValues);
		desiredRelativePosLVC = {0, 0, 0};
		
		opt.Reset(1);
		opt.AddStateVariableBlock(3, "dv", 0.001, -0.01, 0.01);
		opt.AddConstraintBlock(3, "relativePos", 0, 0);
		
		opt.SaveObjectToProcess(deployableSat);
		opt.SaveObjectToProcess(blue[0]);
		
		opt.LoadEngine();
		While (opt.IsRunning());
			opt.UpdateStateVariables();
			opt.RestoreObjectsInProcess();
			burn.BurnDirection = opt.GetStateVariableValues();
			
			deployableSat.Maneuver(burn);
			
			futureEpoch = blue[0].Epoch + rendezvousTime;
			WhileStepping blue[0] to (blue[0].Epoch == futureEpoch);
				deployableSat.StepToEpoch(blue[0].Epoch);
			End;
			
			relativePos = RelativeMotionUtilities.ConvertRelativePosition(0, 6, deployableSat, blue[0].Position - deployableSat.Position);
			opt.SetConstraintValues(desiredRelativePosLVC - relativePos);
			
			opt.Minimize(burn.BurnDirection.Norm);
			
			If (opt.OptimizationPhase == 1);
				Report opt.NominalEvaluationCount, opt.ObjectiveFunctionValue, opt.MaximumInfeasibility, opt.MaximumInfeasibilitySource;
			End;
		End;
		
		Report opt.ReturnString;
		opt.RestoreObjectsInProcess();
		
		burn.BurnDirection = opt.GetBestStateVariableValues();
		Report burn.BurnDirection;
		
		Call OpenForWrite("SavedValues/DisableScript_Red1Burn3.txt");
		file.PutLine(burn.BurnDirection[0].ToString());
		file.PutLine(burn.BurnDirection[1].ToString());
		file.PutLine(burn.BurnDirection[2].ToString());
		file.Close();
	End;
//EndBlock PRESOLVED OPTIMIZATION
	
	Call OpenForRead("SavedValues/DisableScript_Red1Burn3.txt");
	burn.BurnDirection[0] = file.GetLine().ToVariable();
	burn.BurnDirection[1] = file.GetLine().ToVariable();
	burn.BurnDirection[2] = file.GetLine().ToVariable();
	file.Close();
	
	deployableSat.Maneuver(burn);
	
	futureEpoch = blue[0].Epoch + rendezvousTime;
	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);
	
	deployableSat.SetCartesianState(blue[0].GetCartesianState());
	
	futureEpoch = blue[0].Epoch + killOperationTime;
	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);
	
	// Inspector return to Red 1
	
//Block PRESOLVED OPTIMIZATION
	If (doOptimizationAndSaveValues);
		desiredRelativePosLVC = {0, 0, 0};
		
		opt.Reset(1);
		opt.AddStateVariableBlock(3, "dv", 0.001, -0.01, 0.01);
		opt.AddConstraintBlock(3, "relativePos", 0, 0);
		
		opt.SaveObjectToProcess(deployableSat);
		opt.SaveObjectToProcess(red[0]);
		
		opt.LoadEngine();
		While (opt.IsRunning());
			opt.UpdateStateVariables();
			opt.RestoreObjectsInProcess();
			burn.BurnDirection = opt.GetStateVariableValues();
			
			deployableSat.Maneuver(burn);
			
			futureEpoch = red[0].Epoch + rendezvousTime;
			WhileStepping red[0] to (red[0].Epoch == futureEpoch);
				deployableSat.StepToEpoch(red[0].Epoch);
			End;
			
			relativePos = RelativeMotionUtilities.ConvertRelativePosition(0, 6, deployableSat, red[0].Position - deployableSat.Position);
			opt.SetConstraintValues(desiredRelativePosLVC - relativePos);
			
			opt.Minimize(burn.BurnDirection.Norm);
			
			If (opt.OptimizationPhase == 1);
				Report opt.NominalEvaluationCount, opt.ObjectiveFunctionValue, opt.MaximumInfeasibility, opt.MaximumInfeasibilitySource;
			End;
		End;
		
		Report opt.ReturnString;
		opt.RestoreObjectsInProcess();
		
		burn.BurnDirection = opt.GetBestStateVariableValues();
		
		Call OpenForWrite("SavedValues/DisableScript_Red1Burn4.txt");
		file.PutLine(burn.BurnDirection[0].ToString());
		file.PutLine(burn.BurnDirection[1].ToString());
		file.PutLine(burn.BurnDirection[2].ToString());
		file.Close();
	End;
//EndBlock PRESOLVED OPTIMIZATION
	
	Call OpenForRead("SavedValues/DisableScript_Red1Burn4.txt");
	burn.BurnDirection[0] = file.GetLine().ToVariable();
	burn.BurnDirection[1] = file.GetLine().ToVariable();
	burn.BurnDirection[2] = file.GetLine().ToVariable();
	file.Close();
	
	deployableSat.Maneuver(burn);
	
	futureEpoch = blue[0].Epoch + rendezvousTime;
	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);
	
	red.Count -= 1;
	
	futureEpoch = blue[0].Epoch + preDeployWaitTime;
	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);
	
//Block PRESOLVED OPTIMIZATION
	If (doOptimizationAndSaveValues);
		
		opt.Reset(1);
		opt.AddStateVariableBlock(3, "dv1_", 0.001, -0.01, 0.01);
		opt.AddStateVariableBlock(3, "dv2_", 0.001, -0.01, 0.01);
		
		opt.AddConstraint("A", 42164, 42164, 1e1);
		opt.AddConstraint("E", 0, 1e-4);
		opt.AddConstraint("I", 0, 2, 1);
		opt.AddConstraint("lon", 277.2, 277.3, 1, 360);
		
		opt.SaveObjectToProcess(red[0]);
		
		opt.LoadEngine();
		While (opt.IsRunning());
			opt.UpdateStateVariables();
			opt.RestoreObjectsInProcess();
			
			burn.BurnDirection[0] = opt.GetStateVariableValue("dv1_1");
			burn.BurnDirection[1] = opt.GetStateVariableValue("dv1_2");
			burn.BurnDirection[2] = opt.GetStateVariableValue("dv1_3");
			red[0].Maneuver(burn);
			totalDV = burn.BurnDirection.Norm;
			
			futureEpoch = red[0].Epoch + TimeSpan.FromDays(7);
			WhileStepping red[0] to (red[0].Epoch == futureEpoch);
			End;
			
			burn.BurnDirection[0] = opt.GetStateVariableValue("dv2_1");
			burn.BurnDirection[1] = opt.GetStateVariableValue("dv2_2");
			burn.BurnDirection[2] = opt.GetStateVariableValue("dv2_3");
			red[0].Maneuver(burn);
			totalDV += burn.BurnDirection.Norm;
			
			kepState = red[0].GetKeplerianState();
			
			opt.SetConstraintValue("A", red[0].A);
			opt.SetConstraintValue("E", red[0].E);
			opt.SetConstraintValue("I", red[0].I);
			opt.SetConstraintValue("lon", red[0].Longitude);
			
			opt.Minimize(totalDV*1e-1);
			
			If (opt.OptimizationPhase == 1);
				Report opt.NominalEvaluationCount, opt.ObjectiveFunctionValue, opt.MaximumInfeasibility, opt.MaximumInfeasibilitySource;
			End;
		End;
		
		Report opt.ReturnString;
		opt.RestoreObjectsInProcess();
		
		burn.BurnDirection = opt.GetBestStateVariableValues()[0:2];
		
		Call OpenForWrite("SavedValues/DisableScript_Red1Burn5.txt");
		file.PutLine(burn.BurnDirection[0].ToString());
		file.PutLine(burn.BurnDirection[1].ToString());
		file.PutLine(burn.BurnDirection[2].ToString());
		file.Close();
	End;
//EndBlock PRESOLVED OPTIMIZATION
	
	Call OpenForRead("SavedValues/DisableScript_Red1Burn5.txt");
	burn.BurnDirection[0] = file.GetLine().ToVariable();
	burn.BurnDirection[1] = file.GetLine().ToVariable();
	burn.BurnDirection[2] = file.GetLine().ToVariable();
	file.Close();
	
	red[0].Maneuver(burn);
	
	futureEpoch = blue[0].Epoch + TimeSpan.FromDays(7);
	Call AdvanceSimToFutureEpoch(red, blue, futureEpoch);
	
EndProcedure;



//Call BenignScript(red, blue);
Call ObservationScript(red, blue);
//Call DisableScript(red, blue);]]></ProjectScript>
  <ProjectNotes></ProjectNotes>
</FreeFlyerProjectFile>