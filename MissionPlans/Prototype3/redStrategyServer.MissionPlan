<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<FreeFlyerProjectFile xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" timePrecisionMode="nanosecond" schemaVersion="7.8.0.1">
  <ProjectInformation>
    <Author />
    <Source />
    <FreeFlyerVersion>7.8.1.50021</FreeFlyerVersion>
    <RevisionNumber />
    <Title />
    <Subject />
    <Category />
    <Keywords />
    <Comments />
    <Notes />
  </ProjectInformation>
  <ProjectPreferences>
    <General>
      <LockProjectFromEditing>false</LockProjectFromEditing>
    </General>
    <OnOpen>
      <ShowControlSequence>true</ShowControlSequence>
      <ShowEmptyEnvironment>false</ShowEmptyEnvironment>
      <ShowNotes>false</ShowNotes>
      <ShowHome>false</ShowHome>
      <ShowOutput>false</ShowOutput>
      <CreateBackup>false</CreateBackup>
      <BackupLocation></BackupLocation>
    </OnOpen>
    <OnRun>
      <SaveMissionPlan>false</SaveMissionPlan>
      <HideWarningMessages>false</HideWarningMessages>
    </OnRun>
  </ProjectPreferences>
  <ProjectDataFiles>
    <EarthOrientationFile useDefault="true"></EarthOrientationFile>
    <ElectronDensityCoefficientFile useDefault="true"></ElectronDensityCoefficientFile>
    <GeopotentialFile useDefault="true"></GeopotentialFile>
    <HarrisPriesterDragFile useDefault="true"></HarrisPriesterDragFile>
    <JacchiaAtmosphereModelFile useDefault="true"></JacchiaAtmosphereModelFile>
    <LeapSecondFile useDefault="true"></LeapSecondFile>
    <MagneticFieldFile useDefault="true"></MagneticFieldFile>
    <PlanetaryFile useDefault="true"></PlanetaryFile>
    <StationGeodeticsFile useDefault="true"></StationGeodeticsFile>
    <SolidTideFile useDefault="true"></SolidTideFile>
    <DSTFile useDefault="true"></DSTFile>
    <StarFieldFile useDefault="true"></StarFieldFile>
  </ProjectDataFiles>
  <ProjectObjects>
    <Object>
      <SolarSystem name="FF_SolarSystem" isConstant="false" isGlobal="true">
        <Name>FF_SolarSystem</Name>
        <ComputePolarMotion>true</ComputePolarMotion>
        <ApplyUT1Correction>true</ApplyUT1Correction>
        <COUpdateInterval units="s" displayed_units="s">0</COUpdateInterval>
        <NPUpdateInterval units="s" displayed_units="s">1800</NPUpdateInterval>
        <IonosphereOptions>
          <IonosphereOptions name="FF_SolarSystem_|ionoOptions|" isConstant="false" isGlobal="true">
            <Name>FF_SolarSystem_|ionoOptions|</Name>
            <MaximumHeight units="km" displayed_units="km">1000</MaximumHeight>
            <MinimumHeight units="km" displayed_units="km">80</MinimumHeight>
            <IntegrationStepSize units="km" displayed_units="km">25</IntegrationStepSize>
            <ScaleFactor units="" displayed_units="">1</ScaleFactor>
            <Model>0</Model>
            <metadata dim="0" />
          </IonosphereOptions>
        </IonosphereOptions>
        <NoradKeplerEqTolerance units="" displayed_units="">1e-12</NoradKeplerEqTolerance>
        <metadata dim="0" />
      </SolarSystem>
    </Object>
    <Object>
      <ConsoleWindow name="Console" isConstant="false" isGlobal="true">
        <Name>Console</Name>
        <WindowTitle>Console</WindowTitle>
        <WordWrap>false</WordWrap>
        <CurrentTextColor>12245189</CurrentTextColor>
        <BackColor>2039583</BackColor>
        <Dimension units="" displayed_units="">40</Dimension>
        <DockMode>3</DockMode>
        <CurrentFontType>0</CurrentFontType>
        <UseStdOut>false</UseStdOut>
        <ShowOnRun>true</ShowOnRun>
        <metadata dim="0" />
      </ConsoleWindow>
    </Object>
    <Object>
      <ConsoleWindow name="ConsoleSolver" isConstant="false" isGlobal="true">
        <Name>ConsoleSolver</Name>
        <WindowTitle>Console</WindowTitle>
        <WordWrap>false</WordWrap>
        <CurrentTextColor>12245189</CurrentTextColor>
        <BackColor>2039583</BackColor>
        <Dimension units="" displayed_units="">90</Dimension>
        <DockMode>4</DockMode>
        <CurrentFontType>0</CurrentFontType>
        <UseStdOut>false</UseStdOut>
        <ShowOnRun>true</ShowOnRun>
        <metadata dim="0" />
      </ConsoleWindow>
    </Object>
  </ProjectObjects>
  <ProjectMissionSequence>
    <ProjectExternals>
      <ProjectExternal included="true" autosave="true" contentType="FreeFlyerScript">.\Procedures\Common.FFProcedure</ProjectExternal>
    </ProjectExternals>
    <ProjectCommands>
      <FreeForm enabled="true">
        <Label>FreeForm</Label>
        <Bookmarks />
        <Breakpoints />
        <FreeFormScript><![CDATA[
Variable strategyRequest;

Array blueCartState(6);
Array red1CartState(6);
Array red2CartState(6);
Array red3CartState(6);
Array initialCartState(6);
Array desiredKepState(6);
Variable desiredLongitude;
Variable initialEpochDays;
Variable computationDelayHours;
Array interBurnTimeBoundsDays(2);
Variable slewAngle;

Array dv1(3);
Array dv2(3);
Variable interBurnTimeDays;

TimeSpan interBurnTime;
Variable epochDays;

Formation red;
Formation blue;
Call InitializeFormations(red, blue);
blue[0].Propagator.StepSize = TimeSpan.FromSeconds(800);

(blue[0].Propagator AsType Integrator).FixedStep = 0;
(red[0].Propagator AsType Integrator).FixedStep = 0;
(red[1].Propagator AsType Integrator).FixedStep = 0;
(red[2].Propagator AsType Integrator).FixedStep = 0;

Global List<QueuedAction> actions;

Global Array lastStableBlueGeoOrbit(6);

Global Variable lastBlueRadius;
Global Variable lastBlueLongitude;

Global Socket connection;
connection.SocketType = "server";
connection.PortNumber = redStrategyServerPort;
connection.SocketTimeout = -1;


Global TimeSpan red2and3TransitOrbitTime = TimeSpan.FromDays(0.2);]]></FreeFormScript>
      </FreeForm>
      <FreeForm enabled="true">
        <Label>FreeForm</Label>
        <Bookmarks />
        <Breakpoints />
        <FreeFormScript><![CDATA[
Define Procedure HasBlueManeuvered(Spacecraft blue, Variable blueHasManeuvered);
	blueHasManeuvered = 0;
	If (abs(blue.Radius - lastBlueRadius) > 3
			or abs(blue.Longitude - lastBlueLongitude) > 0.05);
		blueHasManeuvered = 1;
		lastBlueLongitude = blue.Longitude;
		lastBlueRadius = blue.Radius;
	End;
EndProcedure;


Define Procedure ComputeDeltaMeanMotion(Variable rp, Variable ra, Variable meanMotionBlue, Variable deltaMeanMotion);
	Variable A = (rp + ra) / 2;
	deltaMeanMotion = 1 / sqrt(A^3 / Earth.Mu) - meanMotionBlue;
EndProcedure;


Define Procedure ComputeRed2Or3DriftOrbitRadius(
		Spacecraft red,
		Spacecraft blue,
		TimeSpan incursionEpoch,
		Variable arrivalRadius,
		TimeSpan driftTime,
		Variable driftOrbitRadius);
	
	Variable deltaMeanMotion_a;
	Variable deltaMeanMotion_b;
	Variable deltaMeanMotion_c;
	Variable deltaMeanMotion_d;
	
	Variable meanMotionBlue = blue.MeanMotion;
	
	Variable r_0 = red.Radius;
	Variable r_d = arrivalRadius;
	Variable r_b;
	
	Variable L_B = blue.Longitude;
	Variable L_0 = red.Longitude;
	
	Call ComputeDeltaMeanMotion(r_d, r_d, meanMotionBlue, deltaMeanMotion_d);
	
	Optimizer opt;
	opt.Reset(1);
	opt.AddStateVariable("r_b", r_0, r_0 - 500, r_0 + 500, 1e3);
	
	opt.AddConstraint("c", 0, 0);
	
	opt.MaximumNominalEvaluationCount = 100;
	opt.LoadEngine();
	While (opt.IsRunning());
		opt.UpdateStateVariables();
		r_b = opt.GetStateVariableValue(0);
		
		Call ComputeDeltaMeanMotion(r_0, r_b, meanMotionBlue, deltaMeanMotion_a);
		Call ComputeDeltaMeanMotion(r_b, r_b, meanMotionBlue, deltaMeanMotion_b);
		Call ComputeDeltaMeanMotion(r_b, r_d, meanMotionBlue, deltaMeanMotion_c);
		
		opt.SetConstraintValue(0, 
			rad(L_B - L_0)
			- (deltaMeanMotion_a + deltaMeanMotion_c + deltaMeanMotion_d) * red2and3TransitOrbitTime.ToSeconds()
			- deltaMeanMotion_b * driftTime.ToSeconds());
		
		opt.Minimize(0);
		
//		If (opt.OptimizationPhase == 1);
//			Report opt.NominalEvaluationCount, "   ", r_b, "   ",
//			opt.ObjectiveFunctionValue, "   ",
//			opt.MaximumInfeasibility, "   ",
//			opt.MaximumInfeasibilitySource to ConsoleSolver;
//		End;
	End;
	
	driftOrbitRadius = opt.GetBestStateVariableValues()[0];
EndProcedure;


Define Procedure ComputeRed1DriftOrbitRadius(
		Spacecraft red,
		Spacecraft blue,
		TimeSpan incursionEpoch,
		TimeSpan driftTime,
		Variable driftOrbitRadius);
	
	Variable deltaMeanMotion;
	
	Variable meanMotionBlue = blue.MeanMotion;
	
	Variable r;
	Variable r_0 = red.Radius;
	
	Variable L_B = blue.Longitude;
	Variable L_0 = red.Longitude;
	
	Optimizer opt;
	opt.Reset(1);
	opt.AddStateVariable("r", r_0, r_0 - 500, r_0 + 500, 1e3);
	
	opt.AddConstraint("c", 0, 0);
	
	opt.MaximumNominalEvaluationCount = 100;
	opt.LoadEngine();
	While (opt.IsRunning());
		opt.UpdateStateVariables();
		r = opt.GetStateVariableValue(0);
		
		Call ComputeDeltaMeanMotion(r, r, meanMotionBlue, deltaMeanMotion);
		opt.SetConstraintValue(0, 
			rad(L_B - 0.31 - L_0) - deltaMeanMotion * driftTime.ToSeconds());
		
		opt.Minimize(0);
		
//		If (opt.OptimizationPhase == 1);
//			Report opt.NominalEvaluationCount, "   ", r_b, "   ",
//			opt.ObjectiveFunctionValue, "   ",
//			opt.MaximumInfeasibility, "   ",
//			opt.MaximumInfeasibilitySource to ConsoleSolver;
//		End;
	End;
	
	driftOrbitRadius = opt.GetBestStateVariableValues()[0];
EndProcedure;


Define Procedure TargetNewOrbitSingleBurn(
		Spacecraft sc,
		Variable r_1,
		Variable r_2,
		Array dv);
	Variable r_p;
	Variable r_a;
	
	If (r_1 < r_2);
		r_p = r_1;
		r_a = r_2;
	Else;
		r_p = r_2;
		r_a = r_1;
	End;
	
	Optimizer opt;
	opt.Reset(1);
	opt.AddStateVariableBlock(2, "dv", 0.001, -0.01, 0.01);
	
	opt.SaveObjectToProcess(sc);
	opt.MaximumNominalEvaluationCount = 40;
	opt.FiniteDifferenceMethod = 1;
	
	IpoptOptions ipopt;
	ipopt.Tolerance = 1e-2;
	opt.LoadEngine(ipopt);
	While (opt.IsRunning());
		opt.UpdateStateVariables();
		opt.RestoreObjectsInProcess();
		
		burn.BurnDirection[0:1] = opt.GetStateVariableValues();
		sc.Maneuver(burn);
		 
		opt.Minimize(
		(sc.Periapsis - r_p)^2 +
		(sc.Apoapsis - r_a)^2);
		
//		If (opt.OptimizationPhase == 1);
//			Report opt.NominalEvaluationCount, "   ",
//			opt.ObjectiveFunctionValue, "   ",
//			opt.MaximumInfeasibility, "   ",
//			opt.MaximumInfeasibilitySource to ConsoleSolver;
//		End;
		
	End;
	
	Report opt.ReturnString to ConsoleSolver;
	opt.RestoreObjectsInProcess();
		
	dv.Dimension = 3;
	dv[0] = opt.GetBestStateVariableValue("dv1");
	dv[1] = opt.GetBestStateVariableValue("dv2");
	dv[2] = 0;
EndProcedure;


Define Procedure IsBlueInStableGeoOrbit(Spacecraft blue, Variable blueIsInStableGeoOrbit);
	blueIsInStableGeoOrbit = 0;
	If (abs(blue.Radius - 42164) < 3);
		If (blue.E < 0.001);
			blueIsInStableGeoOrbit = 1;
		End;
	End;
	
EndProcedure;

Define Procedure WillUpdateOccur(Spacecraft blue, Variable updateWillOccur);
	updateWillOccur = 1;
	Variable blueHasManeuvered;
	Call HasBlueManeuvered(blue, blueHasManeuvered);
	If (!blueHasManeuvered);
		updateWillOccur = 0;
		Report "Blue has not maneuvered since last update" to Console;
		ExitProcedure;
	End;
	
	Variable blueIsInStableGeoOrbit;
	Call IsBlueInStableGeoOrbit(blue, blueIsInStableGeoOrbit);
	If (!blueIsInStableGeoOrbit);
		updateWillOccur = 0;
		Report "Blue is not in a stable GEO orbit" to Console;
		ExitProcedure;
	End;
	
	
EndProcedure;

Define Procedure AddBurnToActions(Array dv, TimeSpan epoch, Variable formationIndex);
	Alias lastAction = actions[actions.Count - 1];
	actions.Count += 1;
	lastAction.epoch = epoch;
	lastAction.burnRIC = dv;
	lastAction.additionalAction = additionalAction_none;
	lastAction.isBlue = 0;
	lastAction.formationIndex = formationIndex;
EndProcedure;

Define Procedure AddJammerToggleToActions(TimeSpan epoch);
	Alias lastAction = actions[actions.Count - 1];
	actions.Count += 1;
	lastAction.epoch = epoch;
	lastAction.burnRIC = {0,0,0};
	lastAction.additionalAction = additionalAction_redToggleJamming;
	lastAction.isBlue = 0;
	lastAction.formationIndex = 0;
EndProcedure;


Define Procedure visualize(Optimizer opt, ViewWindow vw, Variable clearTails);
	Variable phase;
	Variable node;
	Array colors = ColorTools.GetPaletteColors("Light");
	
	If (clearTails);
		vw.ResetTails();
	End;
	
	vw.BeginBatchUpdate();
	For phase = 0 to opt.TrajectoryPhases.Count - 1;
		opt.TrajectoryPhases[phase].PathConstantColor = colors[phase];
		For node = 0 to opt.TrajectoryPhases[phase].NumberOfNodes - 1;
			opt.TrajectoryPhases[phase].NodeIndexToView = node;
			Update vw;
		End;
		opt.TrajectoryPhases[phase].NodeIndexToView = -999;
		vw.InsertLineBreak();
	End;
	vw.EndBatchUpdate();
EndProcedure;

Define Procedure ComputeDisableScriptRed2And3TransitManeuversAndAddToActions(
		Spacecraft red,
		Spacecraft blue,
		TimeSpan incursionEpoch,
		TimeSpan driftTime,
		Variable redIndex);
	List<Array> burns(6);
	List<TimeSpan> burnEpochs(6);
	Variable driftOrbitRadius;
	Variable incursionRadialSeparation = 60;
	Variable factor = 1;
	If (redIndex == 2);
		factor = -1;
	End;
	
	Variable arrivalRadius = blue.Radius - factor*incursionRadialSeparation;
	
	Call ComputeRed2Or3DriftOrbitRadius(red, blue, incursionEpoch, arrivalRadius, driftTime, driftOrbitRadius);
	Array dv;
	
	red.Save("IC");
	Variable initialA = red.A;
	Variable initalI = red.I;
	
	Call TargetNewOrbitSingleBurn(red, red.Radius, driftOrbitRadius, burns[0]);
	burnEpochs[0] = red.Epoch;
	burn.BurnDirection = burns[0];
	red.Maneuver(burn);
	red.StepToEpoch(red.Epoch + red2and3TransitOrbitTime);
	
	Call TargetNewOrbitSingleBurn(red, driftOrbitRadius, driftOrbitRadius, burns[1]);
	burnEpochs[1] = red.Epoch;
	burn.BurnDirection = burns[1];
	red.Maneuver(burn);
	red.StepToEpoch(red.Epoch + driftTime);
	
	Call TargetNewOrbitSingleBurn(red, driftOrbitRadius, arrivalRadius, burns[2]);
	burnEpochs[2] = red.Epoch;
	burn.BurnDirection = burns[2];
	red.Maneuver(burn);
	red.StepToEpoch(red.Epoch + red2and3TransitOrbitTime);
	
	Call TargetNewOrbitSingleBurn(red, arrivalRadius, arrivalRadius, burns[3]);
	burnEpochs[3] = red.Epoch;
	burn.BurnDirection = burns[3];
	red.Maneuver(burn);
	red.StepToEpoch(red.Epoch + red2and3TransitOrbitTime);
	
	Call TargetNewOrbitSingleBurn(red, arrivalRadius, blue.Radius + factor*incursionRadialSeparation, burns[4]);
	burnEpochs[4] = red.Epoch;

	burns[5] = -burns[4];
	burnEpochs[5] = red.Epoch + TimeSpan.FromMinutes(red.Period);
	
	red.Restore("IC");
	
	Variable i;
	Optimizer opt;
	opt.Reset(1);
	For i = 0 to burns.Count - 1;
		opt.AddStateVariable("burn" + (i+1).ToString() + "1", burns[i][0], -0.01, 0.01);
		opt.AddStateVariable("burn" + (i+1).ToString() + "2", burns[i][1], -0.01, 0.01);
		opt.AddStateVariable("burnEpoch" + (i+1).ToString(),  burnEpochs[i].ToDays(), burnEpochs[i].ToDays() - 0.1, burnEpochs[i].ToDays() + 0.1);
	End;
	
	Variable lonAdjustment = 0.0;
	
	opt.AddConstraint("startTime", red.Epoch.ToDays(), red.Epoch.ToDays());
	opt.AddConstraint("driftE", 0, 0, 1000);
	opt.AddConstraint("arrivalRadius", arrivalRadius, arrivalRadius, 100);
	opt.AddConstraint("arrivalRdotV", 0, 0);
	opt.AddConstraint("arrivalLon", blue.Longitude + lonAdjustment, blue.Longitude + lonAdjustment, 1);
	opt.AddConstraint("arrivalTime", incursionEpoch.ToDays(), incursionEpoch.ToDays());
	opt.AddConstraint("rpoRp", blue.A-incursionRadialSeparation, blue.A-incursionRadialSeparation, 100);
	opt.AddConstraint("rpoRa", blue.A+incursionRadialSeparation, blue.A+incursionRadialSeparation, 100);
	opt.AddConstraint("rpoDuration", 1, 1);
	opt.AddConstraintBlock(2, "lastBurn", 0, 0);
	
	opt.SaveObjectToProcess(red);
	
	opt.MaximumNominalEvaluationCount = 70;
	opt.FeasibilityTolerance = 1e-6;
	opt.FiniteDifferenceMethod = 1;
	
	Variable totalDV;
	
	IpoptOptions ipopt;
	ipopt.Tolerance = 1e-3;
	opt.LoadEngine(ipopt);
	While (opt.IsRunning());
		opt.UpdateStateVariables();
		opt.RestoreObjectsInProcess();
		
		totalDV = 0;
		For i = 0 to burns.Count - 1;
			burns[i][0] = opt.GetStateVariableValue("burn" + (i+1).ToString() + "1");
			burns[i][1] = opt.GetStateVariableValue("burn" + (i+1).ToString() + "2");
			burns[i][2] = 0;
			burnEpochs[i] = TimeSpan.FromDays(opt.GetStateVariableValue("burnEpoch" + (i+1).ToString()));
			red.StepToEpoch(burnEpochs[i]);
			burn.BurnDirection = burns[i];
			totalDV += burns[i].Norm;
			
			If (i == 4);
				opt.SetConstraintValue("arrivalRadius", red.Radius);
				opt.SetConstraintValue("arrivalRdotV", red.Position.Normalized.DotProduct(red.Velocity.Normalized));
				opt.SetConstraintValue("arrivalLon", red.Longitude);
				opt.SetConstraintValue("arrivalTime", red.Epoch.ToDays());
			End;
				
			red.Maneuver(burn);
			
			If (i == 1);
				opt.SetConstraintValue("driftE", red.Periapsis - red.Apoapsis);
			ElseIf (i == 4);
				opt.SetConstraintValue("rpoRp", red.Periapsis);
				opt.SetConstraintValue("rpoRa", red.Apoapsis);
			End;
		End;
		
		opt.SetConstraintValue("startTime", burnEpochs[0].ToDays());
		opt.SetConstraintValue("rpoDuration", (burnEpochs[5] - burnEpochs[4]).ToDays());
		opt.SetConstraintValue("lastBurn1", burns[5][0] + burns[4][0]);
		opt.SetConstraintValue("lastBurn2", burns[5][1] + burns[4][1]);
	
		
		opt.Minimize(totalDV*1);
	
		
//		If (opt.OptimizationPhase == 1);
//			Report opt.NominalEvaluationCount, "   ",
//			opt.ObjectiveFunctionValue, "   ",
//			opt.MaximumInfeasibility, "   ",
//			opt.MaximumInfeasibilitySource to ConsoleSolver;
//		End;
		
	End;
	Report opt.ReturnString, "Best DV: " + (opt.GetBestObjectiveFunctionValue() / 1).ToString() to ConsoleSolver;
	opt.RestoreObjectsInProcess();
		
		
		
		
		
	
//	List<TrajectoryPhase> traj;
//	traj.Count = 0;
//	traj.Count = burns.Count + 1;
//	TimeSpan duration;
//	Variable nodesPerRev = 40;
//	Variable numNodes;
//	red.StepToEpoch(red.Epoch - TimeSpan.FromHours(1));
//	For i = 0 to burns.Count - 1;
//		duration = burnEpochs[i] - red.Epoch;
//		numNodes = max(3, nodesPerRev * duration.ToDays());
//		traj[i].AddNodes(red, duration, numNodes, 0);
//		traj[i].SetPositionBounds("path", -42164*1.2, 42164*1.2);
//		burn.BurnDirection = burns[i];
//		red.Maneuver(burn);
//	End;
//	traj[burns.Count].AddNodes(red, TimeSpan.FromHours(1), 3, 0);
//	
//	traj[0].Lock("first");
//	traj[0].LockTimeOfFlight();
//	
//	traj[4].LockEpoch("last", incursionEpoch);
//	traj[4].AddRadiusConstraint("last", arrivalRadius, arrivalRadius);
//	
//	traj[6].LockTimeOfFlight();
//	
//	Optimizer opt;
//	opt.Reset(1);
//	For i = 0 to traj.Count - 1;
//		opt.AddTrajectoryPhase(traj[i]);
//	End;
//	
//	For i = 0 to traj.Count - 2;
//		opt.AddPhasePositionLink(traj[i], traj[i+1]);
//		opt.AddPhaseMassLink(traj[i], traj[i+1]);
//		opt.AddPhaseEpochLink(traj[i], traj[i+1]);
//		opt.AddPhaseLinkDeltaVConstraint(traj[i], traj[i+1], 0.01);
//	End;
//	
//	opt.SaveObjectToProcess(blue);
//	
//	opt.AddConstraint("rpoLon", blue.Longitude, blue.Longitude);
//	opt.AddConstraint("rpoRdotV", 0, 0);
//	opt.AddConstraint("rpoRp", blue.A-incursionRadialSeparation, blue.A-incursionRadialSeparation, 100);
//	opt.AddConstraint("rpoRa", blue.A+incursionRadialSeparation, blue.A+incursionRadialSeparation, 100);
//	opt.AddConstraint("rpoDuration", 0, 0);
//	opt.AddConstraint("finalA", initialA, initialA, 100);
//	opt.AddConstraint("driftE", 0, 0, 1000);
//	
//	opt.AddConstraintBlock(traj.Count, "I", 0, 0, 100);
////	opt.AddConstraint("finalE", 0, 0);
//	
//	opt.MaximumNominalEvaluationCount = 400;
//	opt.FeasibilityTolerance = 1e-4;
//	opt.FiniteDifferenceMethod = 1;
//	
//	Variable totalDV;
//	
//	IpoptOptions ipopt;
//	ipopt.Tolerance = 1e-3;
//	opt.LoadEngine(ipopt);
//	While (opt.IsRunning());
//		opt.UpdateStateVariables();
//		opt.RestoreObjectsInProcess();
//		
//		traj[2].FirstNode.SetSpacecraftState(red);
//		opt.SetConstraintValue("driftE", red.Periapsis - red.Apoapsis);
//		
//		traj[5].FirstNode.SetSpacecraftState(red);
//		opt.SetConstraintValue("rpoLon", red.Longitude);
//		opt.SetConstraintValue("rpoRdotV", red.Position.Normalized.DotProduct(red.Velocity.Normalized));
//		opt.SetConstraintValue("rpoRp", red.Periapsis);
//		opt.SetConstraintValue("rpoRa", red.Apoapsis);
//		opt.SetConstraintValue("rpoDuration", blue.Period - traj[5].TimeOfFlight.ToMinutes());
//		
//		traj[6].FirstNode.SetSpacecraftState(red);
//		opt.SetConstraintValue("finalA", red.A);
////		opt.SetConstraintValue("finalE", red.E);
//		
//		For i = 0 to traj.Count - 1;
//			traj[i].FirstNode.SetSpacecraftState(red);
//			opt.SetConstraintValue("I" + (i+1).ToString(), red.I - initalI);
//		End;
//		
//		totalDV = 0;
//		For i = 0 to traj.Count - 2;
//			totalDV += traj[i].ComputeInterphaseDeltaV(traj[i+1]).Norm;
//		End;
//		opt.Minimize(totalDV*10);
//		
//		
//		If (opt.OptimizationPhase == 1);
//			Report opt.NominalEvaluationCount, "   ",
//			opt.ObjectiveFunctionValue, "   ",
//			opt.MaximumInfeasibility, "   ",
//			opt.MaximumInfeasibilitySource to ConsoleSolver;
//		End;
//		
//	End;
//	Report opt.ReturnString, "Best DV: " + (opt.GetBestObjectiveFunctionValue() / 10).ToString() to ConsoleSolver;
//	opt.RestoreObjectsInProcess();
//	opt.Reset();
//	
//	red.Restore("IC");
//	
//	For i = 0 to burns.Count;
//		traj[i].ApplyBestSolution();		
//	End;
	
	For i = 0 to burns.Count - 1;
//		red.StepToEpoch(traj[i+1].FirstNode.Epoch);
//		burnEpochs[i] = red.Epoch;
//		burns[i] = AttitudeConvert(0, 6, red, traj[i].ComputeInterphaseDeltaV(traj[i+1]));
		
		burns[i][0] = opt.GetBestStateVariableValue("burn" + (i+1).ToString() + "1");
		burns[i][1] = opt.GetBestStateVariableValue("burn" + (i+1).ToString() + "2");
		burns[i][2] = 0;
		burnEpochs[i] = TimeSpan.FromDays(opt.GetBestStateVariableValue("burnEpoch" + (i+1).ToString()));
		
		Call AddBurnToActions(burns[i], burnEpochs[i], redIndex);
		
	End;
	red.Restore("IC");
	
EndProcedure;


Define Procedure ComputeDisableScriptRed1TransitManeuversAndAddToActions(
		Spacecraft red,
		Spacecraft blue,
		TimeSpan incursionEpoch,
		TimeSpan driftTime);
	Variable driftOrbitRadius;
	Call ComputeRed1DriftOrbitRadius(red, blue, incursionEpoch, driftTime, driftOrbitRadius);
	
	Array desiredKepState;
	desiredKepState = red.GetKeplerianState();
	desiredKepState[0] = driftOrbitRadius;
	desiredKepState[1] = 1e-6;
	
	Array dv1(3);
	Array dv2(3);
	TimeSpan interBurnTime;
	Call TargetNewOrbit(
		red,
		desiredKepState,
		-999,
		{0.4, 0.6},
		dv1,
		dv2,
		interBurnTime);
	
	Call AddBurnToActions(dv1, red.Epoch, 0);
	Call AddBurnToActions(dv2, red.Epoch + interBurnTime, 0);
	
	burn.BurnDirection = dv1;
	red.Maneuver(burn);
	red.StepToEpoch(red.Epoch + interBurnTime);
	burn.BurnDirection = dv2;
	red.Maneuver(burn);
	
	red.StepToEpoch(incursionEpoch);
	blue.StepToEpoch(red.Epoch);
	
	desiredKepState = blue.GetKeplerianState();
	desiredKepState[1] += 0.001;
	desiredKepState[2] = red.I;
	
	Call TargetNewRelativeOrbit(
		red,
		blue,
		desiredKepState,
		{0.01, 0.3},
		dv1,
		dv2,
		interBurnTime);
	
	Call AddBurnToActions(dv1, red.Epoch, 0);
	Call AddBurnToActions(dv2, red.Epoch + interBurnTime, 0);
	
EndProcedure;


Define Procedure ReturnToNominal(Formation red);
	Array desiredKepState = red[1].GetKeplerianState();
	desiredKepState[0] = 42104;
	desiredKepState[1] = 0;
	
	Array dv1;
	Array dv2;
	TimeSpan interBurnTime;
	Call TargetNewOrbit(
		red[1],
		desiredKepState,
		-999,
		{0.01, 0.5},
		dv1,
		dv2,
		interBurnTime);
	
	Call AddBurnToActions(dv1, red[1].Epoch, 1);
	Call AddBurnToActions(dv2, red[1].Epoch + interBurnTime, 1);
	
	desiredKepState = red[2].GetKeplerianState();
	desiredKepState[0] = 42224;
	desiredKepState[1] = 0;
	
	Call TargetNewOrbit(
		red[2],
		desiredKepState,
		-999,
		{0.01, 0.5},
		dv1,
		dv2,
		interBurnTime);
	
	Call AddBurnToActions(dv1, red[2].Epoch, 2);
	Call AddBurnToActions(dv2, red[2].Epoch + interBurnTime, 2);
EndProcedure;


Define Procedure ComputeDisableScriptStrategy(Formation red, Formation blue, Variable updateHasBeenComputed);
	actions.Clear();
	updateHasBeenComputed = 0;
	
	Variable updateWillOccur = 0;
	Call WillUpdateOccur(blue[0], updateWillOccur);
	If (!updateWillOccur);
		Send "updateWillOccur", 0 to connection; // signal no update
		Report "No update will occur" to Console;
		ExitProcedure;
	End;
	
	TimeSpan incursionEpoch = simStartEpoch + TimeSpan.FromHours(24*4 + 0);
	TimeSpan driftTime = incursionEpoch - blue[0].Epoch - red2and3TransitOrbitTime.Scaled(3);
	
	If (driftTime < red2and3TransitOrbitTime);
		// return to nominal
		Send "updateWillOccur", 1 to connection;
		Report "Drift time too small, returning to nominal" to Console;
		
		updateHasBeenComputed = 1;
		ExitProcedure;
	End;

	Send "updateWillOccur", 1 to connection;
	
	Call ComputeDisableScriptRed1TransitManeuversAndAddToActions(red[0], blue[0], incursionEpoch, driftTime);
	Call ComputeDisableScriptRed2And3TransitManeuversAndAddToActions(red[1], blue[0], incursionEpoch, driftTime, 1);
	Call ComputeDisableScriptRed2And3TransitManeuversAndAddToActions(red[2], blue[0], incursionEpoch, driftTime, 2);
	
	Call AddJammerToggleToActions(incursionEpoch);
	Call AddJammerToggleToActions(incursionEpoch + TimeSpan.FromDays(1));
	
	updateHasBeenComputed = 1;
EndProcedure;





Define Procedure SortActionsByEpoch(TimeSpan simEpoch);
	List<QueuedAction> sortedActions(actions.Count);
	Variable i;
	Variable j;
	
	For i = 0 to actions.Count - 1;
		If (actions[i].epoch < simEpoch);
			If ((actions[i].epoch - simEpoch).ToSeconds() > -20);
				actions[i].epoch = simEpoch;
			Else;
				Diagnostics.ReportErrorMessage(1, "Encountered action epoch that is significantly behind simulation epoch.");
			End;
		End;
	End;
	
	Variable numberOfLesserEpochs;
	For i = 0 to actions.Count - 1;
		numberOfLesserEpochs = 0;
		For j = 0 to actions.Count - 1;
			If (i == j);
				// do nothing
			Else;
				If (actions[i].epoch > actions[j].epoch);
					numberOfLesserEpochs += 1;
				ElseIf (actions[i].epoch == actions[j].epoch and i < j);
					numberOfLesserEpochs += 1;
				End;
			End;
		End;
		
		sortedActions[numberOfLesserEpochs] = actions[i];
	End;
	
	For i = 0 to actions.Count - 1;
		actions[i] = sortedActions[i];
	End;
EndProcedure;]]></FreeFormScript>
      </FreeForm>
      <FreeForm enabled="true">
        <Label>FreeForm</Label>
        <Bookmarks />
        <Breakpoints />
        <FreeFormScript><![CDATA[
Variable stepSizeSeconds;
Variable gameMode;
Variable uplinkTimeDays;
TimeSpan epochToStepTo;

Variable i;

Variable updateHasBeenComputed;

While (1);	
	Report "Listening on port ", connection.PortNumber.ToString(), "..." to Console;
	Open connection;
	Console.Clear();
	ConsoleSolver.Clear();
	Report "Connected" to Console;
	
	Receive stepSizeSeconds from connection;
	stepSizeSeconds = 800;
	blue[0].Propagator.StepSize = TimeSpan.FromSeconds(stepSizeSeconds);
	red[0].Propagator.StepSize = TimeSpan.FromSeconds(stepSizeSeconds);
	red[1].Propagator.StepSize = TimeSpan.FromSeconds(stepSizeSeconds);
	red[2].Propagator.StepSize = TimeSpan.FromSeconds(stepSizeSeconds);
	
	Receive gameMode from connection;
	
	// Reset these globals so we get an initial strategy update
	lastBlueRadius = 0;
	lastBlueLongitude = -999;
	
	Try;
		While (1);
			Receive socketVerificationLabel, strategyRequest from connection;
			Call ValidateSocketVerificationLabel("stratUpdateRequest");
			Report "" to Console;
			Report "Recieved request: " to Console;
			
			If (strategyRequest == redStrategyRequest_updateStrategy);
				Report "Update Strategy" to Console;
				
				Receive socketVerificationLabel,
						blueCartState,
						red1CartState,
						red2CartState,
						red3CartState,
						epochDays,
						uplinkTimeDays from connection;
				Call ValidateSocketVerificationLabel("strategyUpdateData");
				
				blue[0].Epoch = TimeSpan.FromDays(epochDays);
				red[0].Epoch = TimeSpan.FromDays(epochDays);
				red[1].Epoch = TimeSpan.FromDays(epochDays);
				red[2].Epoch = TimeSpan.FromDays(epochDays);
				
				blue[0].SetCartesianState(blueCartState);
				red[0].SetCartesianState(red1CartState);
				red[1].SetCartesianState(red2CartState);
				red[2].SetCartesianState(red3CartState);
				
				epochToStepTo = blue[0].Epoch + TimeSpan.FromDays(uplinkTimeDays);
				WhileStepping blue[0] to (blue[0].Epoch == epochToStepTo);
					red.StepToEpoch(blue[0].Epoch);
				End;
				
				If (gameMode == gameMode_benignScript);
					// TODO
				ElseIf (gameMode == gameMode_observationScript);
					// TODO
				ElseIf (gameMode == gameMode_disableScript);
					Call ComputeDisableScriptStrategy(red, blue, updateHasBeenComputed);
				End;
				
				If (updateHasBeenComputed);
					Call SortActionsByEpoch(TimeSpan.FromDays(epochDays));
					Report "Sending data..." to Console;
					Send "numRedActions", actions.Count to connection;
					For i = 0 to actions.Count - 1;
						Send "redAction",
							 actions[i].epoch.ToDays(),
							 actions[i].burnRIC,
							 actions[i].formationIndex,
							 actions[i].additionalAction to connection;
					End;
					Report "Data transfer complete" to Console;
				End;
			End;
		End;
	End;
	
	Close connection;
	Report "" to Console;
	Report "Disconnected" to Console;
	Report "" to Console;
End;]]></FreeFormScript>
      </FreeForm>
    </ProjectCommands>
  </ProjectMissionSequence>
  <ProjectScript><![CDATA[
Variable strategyRequest;

Array blueCartState(6);
Array red1CartState(6);
Array red2CartState(6);
Array red3CartState(6);
Array initialCartState(6);
Array desiredKepState(6);
Variable desiredLongitude;
Variable initialEpochDays;
Variable computationDelayHours;
Array interBurnTimeBoundsDays(2);
Variable slewAngle;

Array dv1(3);
Array dv2(3);
Variable interBurnTimeDays;

TimeSpan interBurnTime;
Variable epochDays;

Formation red;
Formation blue;
Call InitializeFormations(red, blue);
blue[0].Propagator.StepSize = TimeSpan.FromSeconds(800);

(blue[0].Propagator AsType Integrator).FixedStep = 0;
(red[0].Propagator AsType Integrator).FixedStep = 0;
(red[1].Propagator AsType Integrator).FixedStep = 0;
(red[2].Propagator AsType Integrator).FixedStep = 0;

Global List<QueuedAction> actions;

Global Array lastStableBlueGeoOrbit(6);

Global Variable lastBlueRadius;
Global Variable lastBlueLongitude;

Global Socket connection;
connection.SocketType = "server";
connection.PortNumber = redStrategyServerPort;
connection.SocketTimeout = -1;


Global TimeSpan red2and3TransitOrbitTime = TimeSpan.FromDays(0.2);

Define Procedure HasBlueManeuvered(Spacecraft blue, Variable blueHasManeuvered);
	blueHasManeuvered = 0;
	If (abs(blue.Radius - lastBlueRadius) > 3
			or abs(blue.Longitude - lastBlueLongitude) > 0.05);
		blueHasManeuvered = 1;
		lastBlueLongitude = blue.Longitude;
		lastBlueRadius = blue.Radius;
	End;
EndProcedure;


Define Procedure ComputeDeltaMeanMotion(Variable rp, Variable ra, Variable meanMotionBlue, Variable deltaMeanMotion);
	Variable A = (rp + ra) / 2;
	deltaMeanMotion = 1 / sqrt(A^3 / Earth.Mu) - meanMotionBlue;
EndProcedure;


Define Procedure ComputeRed2Or3DriftOrbitRadius(
		Spacecraft red,
		Spacecraft blue,
		TimeSpan incursionEpoch,
		Variable arrivalRadius,
		TimeSpan driftTime,
		Variable driftOrbitRadius);
	
	Variable deltaMeanMotion_a;
	Variable deltaMeanMotion_b;
	Variable deltaMeanMotion_c;
	Variable deltaMeanMotion_d;
	
	Variable meanMotionBlue = blue.MeanMotion;
	
	Variable r_0 = red.Radius;
	Variable r_d = arrivalRadius;
	Variable r_b;
	
	Variable L_B = blue.Longitude;
	Variable L_0 = red.Longitude;
	
	Call ComputeDeltaMeanMotion(r_d, r_d, meanMotionBlue, deltaMeanMotion_d);
	
	Optimizer opt;
	opt.Reset(1);
	opt.AddStateVariable("r_b", r_0, r_0 - 500, r_0 + 500, 1e3);
	
	opt.AddConstraint("c", 0, 0);
	
	opt.MaximumNominalEvaluationCount = 100;
	opt.LoadEngine();
	While (opt.IsRunning());
		opt.UpdateStateVariables();
		r_b = opt.GetStateVariableValue(0);
		
		Call ComputeDeltaMeanMotion(r_0, r_b, meanMotionBlue, deltaMeanMotion_a);
		Call ComputeDeltaMeanMotion(r_b, r_b, meanMotionBlue, deltaMeanMotion_b);
		Call ComputeDeltaMeanMotion(r_b, r_d, meanMotionBlue, deltaMeanMotion_c);
		
		opt.SetConstraintValue(0, 
			rad(L_B - L_0)
			- (deltaMeanMotion_a + deltaMeanMotion_c + deltaMeanMotion_d) * red2and3TransitOrbitTime.ToSeconds()
			- deltaMeanMotion_b * driftTime.ToSeconds());
		
		opt.Minimize(0);
		
//		If (opt.OptimizationPhase == 1);
//			Report opt.NominalEvaluationCount, "   ", r_b, "   ",
//			opt.ObjectiveFunctionValue, "   ",
//			opt.MaximumInfeasibility, "   ",
//			opt.MaximumInfeasibilitySource to ConsoleSolver;
//		End;
	End;
	
	driftOrbitRadius = opt.GetBestStateVariableValues()[0];
EndProcedure;


Define Procedure ComputeRed1DriftOrbitRadius(
		Spacecraft red,
		Spacecraft blue,
		TimeSpan incursionEpoch,
		TimeSpan driftTime,
		Variable driftOrbitRadius);
	
	Variable deltaMeanMotion;
	
	Variable meanMotionBlue = blue.MeanMotion;
	
	Variable r;
	Variable r_0 = red.Radius;
	
	Variable L_B = blue.Longitude;
	Variable L_0 = red.Longitude;
	
	Optimizer opt;
	opt.Reset(1);
	opt.AddStateVariable("r", r_0, r_0 - 500, r_0 + 500, 1e3);
	
	opt.AddConstraint("c", 0, 0);
	
	opt.MaximumNominalEvaluationCount = 100;
	opt.LoadEngine();
	While (opt.IsRunning());
		opt.UpdateStateVariables();
		r = opt.GetStateVariableValue(0);
		
		Call ComputeDeltaMeanMotion(r, r, meanMotionBlue, deltaMeanMotion);
		opt.SetConstraintValue(0, 
			rad(L_B - 0.31 - L_0) - deltaMeanMotion * driftTime.ToSeconds());
		
		opt.Minimize(0);
		
//		If (opt.OptimizationPhase == 1);
//			Report opt.NominalEvaluationCount, "   ", r_b, "   ",
//			opt.ObjectiveFunctionValue, "   ",
//			opt.MaximumInfeasibility, "   ",
//			opt.MaximumInfeasibilitySource to ConsoleSolver;
//		End;
	End;
	
	driftOrbitRadius = opt.GetBestStateVariableValues()[0];
EndProcedure;


Define Procedure TargetNewOrbitSingleBurn(
		Spacecraft sc,
		Variable r_1,
		Variable r_2,
		Array dv);
	Variable r_p;
	Variable r_a;
	
	If (r_1 < r_2);
		r_p = r_1;
		r_a = r_2;
	Else;
		r_p = r_2;
		r_a = r_1;
	End;
	
	Optimizer opt;
	opt.Reset(1);
	opt.AddStateVariableBlock(2, "dv", 0.001, -0.01, 0.01);
	
	opt.SaveObjectToProcess(sc);
	opt.MaximumNominalEvaluationCount = 40;
	opt.FiniteDifferenceMethod = 1;
	
	IpoptOptions ipopt;
	ipopt.Tolerance = 1e-2;
	opt.LoadEngine(ipopt);
	While (opt.IsRunning());
		opt.UpdateStateVariables();
		opt.RestoreObjectsInProcess();
		
		burn.BurnDirection[0:1] = opt.GetStateVariableValues();
		sc.Maneuver(burn);
		 
		opt.Minimize(
		(sc.Periapsis - r_p)^2 +
		(sc.Apoapsis - r_a)^2);
		
//		If (opt.OptimizationPhase == 1);
//			Report opt.NominalEvaluationCount, "   ",
//			opt.ObjectiveFunctionValue, "   ",
//			opt.MaximumInfeasibility, "   ",
//			opt.MaximumInfeasibilitySource to ConsoleSolver;
//		End;
		
	End;
	
	Report opt.ReturnString to ConsoleSolver;
	opt.RestoreObjectsInProcess();
		
	dv.Dimension = 3;
	dv[0] = opt.GetBestStateVariableValue("dv1");
	dv[1] = opt.GetBestStateVariableValue("dv2");
	dv[2] = 0;
EndProcedure;


Define Procedure IsBlueInStableGeoOrbit(Spacecraft blue, Variable blueIsInStableGeoOrbit);
	blueIsInStableGeoOrbit = 0;
	If (abs(blue.Radius - 42164) < 3);
		If (blue.E < 0.001);
			blueIsInStableGeoOrbit = 1;
		End;
	End;
	
EndProcedure;

Define Procedure WillUpdateOccur(Spacecraft blue, Variable updateWillOccur);
	updateWillOccur = 1;
	Variable blueHasManeuvered;
	Call HasBlueManeuvered(blue, blueHasManeuvered);
	If (!blueHasManeuvered);
		updateWillOccur = 0;
		Report "Blue has not maneuvered since last update" to Console;
		ExitProcedure;
	End;
	
	Variable blueIsInStableGeoOrbit;
	Call IsBlueInStableGeoOrbit(blue, blueIsInStableGeoOrbit);
	If (!blueIsInStableGeoOrbit);
		updateWillOccur = 0;
		Report "Blue is not in a stable GEO orbit" to Console;
		ExitProcedure;
	End;
	
	
EndProcedure;

Define Procedure AddBurnToActions(Array dv, TimeSpan epoch, Variable formationIndex);
	Alias lastAction = actions[actions.Count - 1];
	actions.Count += 1;
	lastAction.epoch = epoch;
	lastAction.burnRIC = dv;
	lastAction.additionalAction = additionalAction_none;
	lastAction.isBlue = 0;
	lastAction.formationIndex = formationIndex;
EndProcedure;

Define Procedure AddJammerToggleToActions(TimeSpan epoch);
	Alias lastAction = actions[actions.Count - 1];
	actions.Count += 1;
	lastAction.epoch = epoch;
	lastAction.burnRIC = {0,0,0};
	lastAction.additionalAction = additionalAction_redToggleJamming;
	lastAction.isBlue = 0;
	lastAction.formationIndex = 0;
EndProcedure;


Define Procedure visualize(Optimizer opt, ViewWindow vw, Variable clearTails);
	Variable phase;
	Variable node;
	Array colors = ColorTools.GetPaletteColors("Light");
	
	If (clearTails);
		vw.ResetTails();
	End;
	
	vw.BeginBatchUpdate();
	For phase = 0 to opt.TrajectoryPhases.Count - 1;
		opt.TrajectoryPhases[phase].PathConstantColor = colors[phase];
		For node = 0 to opt.TrajectoryPhases[phase].NumberOfNodes - 1;
			opt.TrajectoryPhases[phase].NodeIndexToView = node;
			Update vw;
		End;
		opt.TrajectoryPhases[phase].NodeIndexToView = -999;
		vw.InsertLineBreak();
	End;
	vw.EndBatchUpdate();
EndProcedure;

Define Procedure ComputeDisableScriptRed2And3TransitManeuversAndAddToActions(
		Spacecraft red,
		Spacecraft blue,
		TimeSpan incursionEpoch,
		TimeSpan driftTime,
		Variable redIndex);
	List<Array> burns(6);
	List<TimeSpan> burnEpochs(6);
	Variable driftOrbitRadius;
	Variable incursionRadialSeparation = 60;
	Variable factor = 1;
	If (redIndex == 2);
		factor = -1;
	End;
	
	Variable arrivalRadius = blue.Radius - factor*incursionRadialSeparation;
	
	Call ComputeRed2Or3DriftOrbitRadius(red, blue, incursionEpoch, arrivalRadius, driftTime, driftOrbitRadius);
	Array dv;
	
	red.Save("IC");
	Variable initialA = red.A;
	Variable initalI = red.I;
	
	Call TargetNewOrbitSingleBurn(red, red.Radius, driftOrbitRadius, burns[0]);
	burnEpochs[0] = red.Epoch;
	burn.BurnDirection = burns[0];
	red.Maneuver(burn);
	red.StepToEpoch(red.Epoch + red2and3TransitOrbitTime);
	
	Call TargetNewOrbitSingleBurn(red, driftOrbitRadius, driftOrbitRadius, burns[1]);
	burnEpochs[1] = red.Epoch;
	burn.BurnDirection = burns[1];
	red.Maneuver(burn);
	red.StepToEpoch(red.Epoch + driftTime);
	
	Call TargetNewOrbitSingleBurn(red, driftOrbitRadius, arrivalRadius, burns[2]);
	burnEpochs[2] = red.Epoch;
	burn.BurnDirection = burns[2];
	red.Maneuver(burn);
	red.StepToEpoch(red.Epoch + red2and3TransitOrbitTime);
	
	Call TargetNewOrbitSingleBurn(red, arrivalRadius, arrivalRadius, burns[3]);
	burnEpochs[3] = red.Epoch;
	burn.BurnDirection = burns[3];
	red.Maneuver(burn);
	red.StepToEpoch(red.Epoch + red2and3TransitOrbitTime);
	
	Call TargetNewOrbitSingleBurn(red, arrivalRadius, blue.Radius + factor*incursionRadialSeparation, burns[4]);
	burnEpochs[4] = red.Epoch;

	burns[5] = -burns[4];
	burnEpochs[5] = red.Epoch + TimeSpan.FromMinutes(red.Period);
	
	red.Restore("IC");
	
	Variable i;
	Optimizer opt;
	opt.Reset(1);
	For i = 0 to burns.Count - 1;
		opt.AddStateVariable("burn" + (i+1).ToString() + "1", burns[i][0], -0.01, 0.01);
		opt.AddStateVariable("burn" + (i+1).ToString() + "2", burns[i][1], -0.01, 0.01);
		opt.AddStateVariable("burnEpoch" + (i+1).ToString(),  burnEpochs[i].ToDays(), burnEpochs[i].ToDays() - 0.1, burnEpochs[i].ToDays() + 0.1);
	End;
	
	Variable lonAdjustment = 0.0;
	
	opt.AddConstraint("startTime", red.Epoch.ToDays(), red.Epoch.ToDays());
	opt.AddConstraint("driftE", 0, 0, 1000);
	opt.AddConstraint("arrivalRadius", arrivalRadius, arrivalRadius, 100);
	opt.AddConstraint("arrivalRdotV", 0, 0);
	opt.AddConstraint("arrivalLon", blue.Longitude + lonAdjustment, blue.Longitude + lonAdjustment, 1);
	opt.AddConstraint("arrivalTime", incursionEpoch.ToDays(), incursionEpoch.ToDays());
	opt.AddConstraint("rpoRp", blue.A-incursionRadialSeparation, blue.A-incursionRadialSeparation, 100);
	opt.AddConstraint("rpoRa", blue.A+incursionRadialSeparation, blue.A+incursionRadialSeparation, 100);
	opt.AddConstraint("rpoDuration", 1, 1);
	opt.AddConstraintBlock(2, "lastBurn", 0, 0);
	
	opt.SaveObjectToProcess(red);
	
	opt.MaximumNominalEvaluationCount = 70;
	opt.FeasibilityTolerance = 1e-6;
	opt.FiniteDifferenceMethod = 1;
	
	Variable totalDV;
	
	IpoptOptions ipopt;
	ipopt.Tolerance = 1e-3;
	opt.LoadEngine(ipopt);
	While (opt.IsRunning());
		opt.UpdateStateVariables();
		opt.RestoreObjectsInProcess();
		
		totalDV = 0;
		For i = 0 to burns.Count - 1;
			burns[i][0] = opt.GetStateVariableValue("burn" + (i+1).ToString() + "1");
			burns[i][1] = opt.GetStateVariableValue("burn" + (i+1).ToString() + "2");
			burns[i][2] = 0;
			burnEpochs[i] = TimeSpan.FromDays(opt.GetStateVariableValue("burnEpoch" + (i+1).ToString()));
			red.StepToEpoch(burnEpochs[i]);
			burn.BurnDirection = burns[i];
			totalDV += burns[i].Norm;
			
			If (i == 4);
				opt.SetConstraintValue("arrivalRadius", red.Radius);
				opt.SetConstraintValue("arrivalRdotV", red.Position.Normalized.DotProduct(red.Velocity.Normalized));
				opt.SetConstraintValue("arrivalLon", red.Longitude);
				opt.SetConstraintValue("arrivalTime", red.Epoch.ToDays());
			End;
				
			red.Maneuver(burn);
			
			If (i == 1);
				opt.SetConstraintValue("driftE", red.Periapsis - red.Apoapsis);
			ElseIf (i == 4);
				opt.SetConstraintValue("rpoRp", red.Periapsis);
				opt.SetConstraintValue("rpoRa", red.Apoapsis);
			End;
		End;
		
		opt.SetConstraintValue("startTime", burnEpochs[0].ToDays());
		opt.SetConstraintValue("rpoDuration", (burnEpochs[5] - burnEpochs[4]).ToDays());
		opt.SetConstraintValue("lastBurn1", burns[5][0] + burns[4][0]);
		opt.SetConstraintValue("lastBurn2", burns[5][1] + burns[4][1]);
	
		
		opt.Minimize(totalDV*1);
	
		
//		If (opt.OptimizationPhase == 1);
//			Report opt.NominalEvaluationCount, "   ",
//			opt.ObjectiveFunctionValue, "   ",
//			opt.MaximumInfeasibility, "   ",
//			opt.MaximumInfeasibilitySource to ConsoleSolver;
//		End;
		
	End;
	Report opt.ReturnString, "Best DV: " + (opt.GetBestObjectiveFunctionValue() / 1).ToString() to ConsoleSolver;
	opt.RestoreObjectsInProcess();
		
		
		
		
		
	
//	List<TrajectoryPhase> traj;
//	traj.Count = 0;
//	traj.Count = burns.Count + 1;
//	TimeSpan duration;
//	Variable nodesPerRev = 40;
//	Variable numNodes;
//	red.StepToEpoch(red.Epoch - TimeSpan.FromHours(1));
//	For i = 0 to burns.Count - 1;
//		duration = burnEpochs[i] - red.Epoch;
//		numNodes = max(3, nodesPerRev * duration.ToDays());
//		traj[i].AddNodes(red, duration, numNodes, 0);
//		traj[i].SetPositionBounds("path", -42164*1.2, 42164*1.2);
//		burn.BurnDirection = burns[i];
//		red.Maneuver(burn);
//	End;
//	traj[burns.Count].AddNodes(red, TimeSpan.FromHours(1), 3, 0);
//	
//	traj[0].Lock("first");
//	traj[0].LockTimeOfFlight();
//	
//	traj[4].LockEpoch("last", incursionEpoch);
//	traj[4].AddRadiusConstraint("last", arrivalRadius, arrivalRadius);
//	
//	traj[6].LockTimeOfFlight();
//	
//	Optimizer opt;
//	opt.Reset(1);
//	For i = 0 to traj.Count - 1;
//		opt.AddTrajectoryPhase(traj[i]);
//	End;
//	
//	For i = 0 to traj.Count - 2;
//		opt.AddPhasePositionLink(traj[i], traj[i+1]);
//		opt.AddPhaseMassLink(traj[i], traj[i+1]);
//		opt.AddPhaseEpochLink(traj[i], traj[i+1]);
//		opt.AddPhaseLinkDeltaVConstraint(traj[i], traj[i+1], 0.01);
//	End;
//	
//	opt.SaveObjectToProcess(blue);
//	
//	opt.AddConstraint("rpoLon", blue.Longitude, blue.Longitude);
//	opt.AddConstraint("rpoRdotV", 0, 0);
//	opt.AddConstraint("rpoRp", blue.A-incursionRadialSeparation, blue.A-incursionRadialSeparation, 100);
//	opt.AddConstraint("rpoRa", blue.A+incursionRadialSeparation, blue.A+incursionRadialSeparation, 100);
//	opt.AddConstraint("rpoDuration", 0, 0);
//	opt.AddConstraint("finalA", initialA, initialA, 100);
//	opt.AddConstraint("driftE", 0, 0, 1000);
//	
//	opt.AddConstraintBlock(traj.Count, "I", 0, 0, 100);
////	opt.AddConstraint("finalE", 0, 0);
//	
//	opt.MaximumNominalEvaluationCount = 400;
//	opt.FeasibilityTolerance = 1e-4;
//	opt.FiniteDifferenceMethod = 1;
//	
//	Variable totalDV;
//	
//	IpoptOptions ipopt;
//	ipopt.Tolerance = 1e-3;
//	opt.LoadEngine(ipopt);
//	While (opt.IsRunning());
//		opt.UpdateStateVariables();
//		opt.RestoreObjectsInProcess();
//		
//		traj[2].FirstNode.SetSpacecraftState(red);
//		opt.SetConstraintValue("driftE", red.Periapsis - red.Apoapsis);
//		
//		traj[5].FirstNode.SetSpacecraftState(red);
//		opt.SetConstraintValue("rpoLon", red.Longitude);
//		opt.SetConstraintValue("rpoRdotV", red.Position.Normalized.DotProduct(red.Velocity.Normalized));
//		opt.SetConstraintValue("rpoRp", red.Periapsis);
//		opt.SetConstraintValue("rpoRa", red.Apoapsis);
//		opt.SetConstraintValue("rpoDuration", blue.Period - traj[5].TimeOfFlight.ToMinutes());
//		
//		traj[6].FirstNode.SetSpacecraftState(red);
//		opt.SetConstraintValue("finalA", red.A);
////		opt.SetConstraintValue("finalE", red.E);
//		
//		For i = 0 to traj.Count - 1;
//			traj[i].FirstNode.SetSpacecraftState(red);
//			opt.SetConstraintValue("I" + (i+1).ToString(), red.I - initalI);
//		End;
//		
//		totalDV = 0;
//		For i = 0 to traj.Count - 2;
//			totalDV += traj[i].ComputeInterphaseDeltaV(traj[i+1]).Norm;
//		End;
//		opt.Minimize(totalDV*10);
//		
//		
//		If (opt.OptimizationPhase == 1);
//			Report opt.NominalEvaluationCount, "   ",
//			opt.ObjectiveFunctionValue, "   ",
//			opt.MaximumInfeasibility, "   ",
//			opt.MaximumInfeasibilitySource to ConsoleSolver;
//		End;
//		
//	End;
//	Report opt.ReturnString, "Best DV: " + (opt.GetBestObjectiveFunctionValue() / 10).ToString() to ConsoleSolver;
//	opt.RestoreObjectsInProcess();
//	opt.Reset();
//	
//	red.Restore("IC");
//	
//	For i = 0 to burns.Count;
//		traj[i].ApplyBestSolution();		
//	End;
	
	For i = 0 to burns.Count - 1;
//		red.StepToEpoch(traj[i+1].FirstNode.Epoch);
//		burnEpochs[i] = red.Epoch;
//		burns[i] = AttitudeConvert(0, 6, red, traj[i].ComputeInterphaseDeltaV(traj[i+1]));
		
		burns[i][0] = opt.GetBestStateVariableValue("burn" + (i+1).ToString() + "1");
		burns[i][1] = opt.GetBestStateVariableValue("burn" + (i+1).ToString() + "2");
		burns[i][2] = 0;
		burnEpochs[i] = TimeSpan.FromDays(opt.GetBestStateVariableValue("burnEpoch" + (i+1).ToString()));
		
		Call AddBurnToActions(burns[i], burnEpochs[i], redIndex);
		
	End;
	red.Restore("IC");
	
EndProcedure;


Define Procedure ComputeDisableScriptRed1TransitManeuversAndAddToActions(
		Spacecraft red,
		Spacecraft blue,
		TimeSpan incursionEpoch,
		TimeSpan driftTime);
	Variable driftOrbitRadius;
	Call ComputeRed1DriftOrbitRadius(red, blue, incursionEpoch, driftTime, driftOrbitRadius);
	
	Array desiredKepState;
	desiredKepState = red.GetKeplerianState();
	desiredKepState[0] = driftOrbitRadius;
	desiredKepState[1] = 1e-6;
	
	Array dv1(3);
	Array dv2(3);
	TimeSpan interBurnTime;
	Call TargetNewOrbit(
		red,
		desiredKepState,
		-999,
		{0.4, 0.6},
		dv1,
		dv2,
		interBurnTime);
	
	Call AddBurnToActions(dv1, red.Epoch, 0);
	Call AddBurnToActions(dv2, red.Epoch + interBurnTime, 0);
	
	burn.BurnDirection = dv1;
	red.Maneuver(burn);
	red.StepToEpoch(red.Epoch + interBurnTime);
	burn.BurnDirection = dv2;
	red.Maneuver(burn);
	
	red.StepToEpoch(incursionEpoch);
	blue.StepToEpoch(red.Epoch);
	
	desiredKepState = blue.GetKeplerianState();
	desiredKepState[1] += 0.001;
	desiredKepState[2] = red.I;
	
	Call TargetNewRelativeOrbit(
		red,
		blue,
		desiredKepState,
		{0.01, 0.3},
		dv1,
		dv2,
		interBurnTime);
	
	Call AddBurnToActions(dv1, red.Epoch, 0);
	Call AddBurnToActions(dv2, red.Epoch + interBurnTime, 0);
	
EndProcedure;


Define Procedure ReturnToNominal(Formation red);
	Array desiredKepState = red[1].GetKeplerianState();
	desiredKepState[0] = 42104;
	desiredKepState[1] = 0;
	
	Array dv1;
	Array dv2;
	TimeSpan interBurnTime;
	Call TargetNewOrbit(
		red[1],
		desiredKepState,
		-999,
		{0.01, 0.5},
		dv1,
		dv2,
		interBurnTime);
	
	Call AddBurnToActions(dv1, red[1].Epoch, 1);
	Call AddBurnToActions(dv2, red[1].Epoch + interBurnTime, 1);
	
	desiredKepState = red[2].GetKeplerianState();
	desiredKepState[0] = 42224;
	desiredKepState[1] = 0;
	
	Call TargetNewOrbit(
		red[2],
		desiredKepState,
		-999,
		{0.01, 0.5},
		dv1,
		dv2,
		interBurnTime);
	
	Call AddBurnToActions(dv1, red[2].Epoch, 2);
	Call AddBurnToActions(dv2, red[2].Epoch + interBurnTime, 2);
EndProcedure;


Define Procedure ComputeDisableScriptStrategy(Formation red, Formation blue, Variable updateHasBeenComputed);
	actions.Clear();
	updateHasBeenComputed = 0;
	
	Variable updateWillOccur = 0;
	Call WillUpdateOccur(blue[0], updateWillOccur);
	If (!updateWillOccur);
		Send "updateWillOccur", 0 to connection; // signal no update
		Report "No update will occur" to Console;
		ExitProcedure;
	End;
	
	TimeSpan incursionEpoch = simStartEpoch + TimeSpan.FromHours(24*4 + 0);
	TimeSpan driftTime = incursionEpoch - blue[0].Epoch - red2and3TransitOrbitTime.Scaled(3);
	
	If (driftTime < red2and3TransitOrbitTime);
		// return to nominal
		Send "updateWillOccur", 1 to connection;
		Report "Drift time too small, returning to nominal" to Console;
		
		updateHasBeenComputed = 1;
		ExitProcedure;
	End;

	Send "updateWillOccur", 1 to connection;
	
	Call ComputeDisableScriptRed1TransitManeuversAndAddToActions(red[0], blue[0], incursionEpoch, driftTime);
	Call ComputeDisableScriptRed2And3TransitManeuversAndAddToActions(red[1], blue[0], incursionEpoch, driftTime, 1);
	Call ComputeDisableScriptRed2And3TransitManeuversAndAddToActions(red[2], blue[0], incursionEpoch, driftTime, 2);
	
	Call AddJammerToggleToActions(incursionEpoch);
	Call AddJammerToggleToActions(incursionEpoch + TimeSpan.FromDays(1));
	
	updateHasBeenComputed = 1;
EndProcedure;





Define Procedure SortActionsByEpoch(TimeSpan simEpoch);
	List<QueuedAction> sortedActions(actions.Count);
	Variable i;
	Variable j;
	
	For i = 0 to actions.Count - 1;
		If (actions[i].epoch < simEpoch);
			If ((actions[i].epoch - simEpoch).ToSeconds() > -20);
				actions[i].epoch = simEpoch;
			Else;
				Diagnostics.ReportErrorMessage(1, "Encountered action epoch that is significantly behind simulation epoch.");
			End;
		End;
	End;
	
	Variable numberOfLesserEpochs;
	For i = 0 to actions.Count - 1;
		numberOfLesserEpochs = 0;
		For j = 0 to actions.Count - 1;
			If (i == j);
				// do nothing
			Else;
				If (actions[i].epoch > actions[j].epoch);
					numberOfLesserEpochs += 1;
				ElseIf (actions[i].epoch == actions[j].epoch and i < j);
					numberOfLesserEpochs += 1;
				End;
			End;
		End;
		
		sortedActions[numberOfLesserEpochs] = actions[i];
	End;
	
	For i = 0 to actions.Count - 1;
		actions[i] = sortedActions[i];
	End;
EndProcedure;

Variable stepSizeSeconds;
Variable gameMode;
Variable uplinkTimeDays;
TimeSpan epochToStepTo;

Variable i;

Variable updateHasBeenComputed;

While (1);	
	Report "Listening on port ", connection.PortNumber.ToString(), "..." to Console;
	Open connection;
	Console.Clear();
	ConsoleSolver.Clear();
	Report "Connected" to Console;
	
	Receive stepSizeSeconds from connection;
	stepSizeSeconds = 800;
	blue[0].Propagator.StepSize = TimeSpan.FromSeconds(stepSizeSeconds);
	red[0].Propagator.StepSize = TimeSpan.FromSeconds(stepSizeSeconds);
	red[1].Propagator.StepSize = TimeSpan.FromSeconds(stepSizeSeconds);
	red[2].Propagator.StepSize = TimeSpan.FromSeconds(stepSizeSeconds);
	
	Receive gameMode from connection;
	
	// Reset these globals so we get an initial strategy update
	lastBlueRadius = 0;
	lastBlueLongitude = -999;
	
	Try;
		While (1);
			Receive socketVerificationLabel, strategyRequest from connection;
			Call ValidateSocketVerificationLabel("stratUpdateRequest");
			Report "" to Console;
			Report "Recieved request: " to Console;
			
			If (strategyRequest == redStrategyRequest_updateStrategy);
				Report "Update Strategy" to Console;
				
				Receive socketVerificationLabel,
						blueCartState,
						red1CartState,
						red2CartState,
						red3CartState,
						epochDays,
						uplinkTimeDays from connection;
				Call ValidateSocketVerificationLabel("strategyUpdateData");
				
				blue[0].Epoch = TimeSpan.FromDays(epochDays);
				red[0].Epoch = TimeSpan.FromDays(epochDays);
				red[1].Epoch = TimeSpan.FromDays(epochDays);
				red[2].Epoch = TimeSpan.FromDays(epochDays);
				
				blue[0].SetCartesianState(blueCartState);
				red[0].SetCartesianState(red1CartState);
				red[1].SetCartesianState(red2CartState);
				red[2].SetCartesianState(red3CartState);
				
				epochToStepTo = blue[0].Epoch + TimeSpan.FromDays(uplinkTimeDays);
				WhileStepping blue[0] to (blue[0].Epoch == epochToStepTo);
					red.StepToEpoch(blue[0].Epoch);
				End;
				
				If (gameMode == gameMode_benignScript);
					// TODO
				ElseIf (gameMode == gameMode_observationScript);
					// TODO
				ElseIf (gameMode == gameMode_disableScript);
					Call ComputeDisableScriptStrategy(red, blue, updateHasBeenComputed);
				End;
				
				If (updateHasBeenComputed);
					Call SortActionsByEpoch(TimeSpan.FromDays(epochDays));
					Report "Sending data..." to Console;
					Send "numRedActions", actions.Count to connection;
					For i = 0 to actions.Count - 1;
						Send "redAction",
							 actions[i].epoch.ToDays(),
							 actions[i].burnRIC,
							 actions[i].formationIndex,
							 actions[i].additionalAction to connection;
					End;
					Report "Data transfer complete" to Console;
				End;
			End;
		End;
	End;
	
	Close connection;
	Report "" to Console;
	Report "Disconnected" to Console;
	Report "" to Console;
End;]]></ProjectScript>
  <ProjectNotes></ProjectNotes>
</FreeFlyerProjectFile>