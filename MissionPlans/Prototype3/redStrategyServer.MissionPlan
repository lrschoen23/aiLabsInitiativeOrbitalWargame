<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<FreeFlyerProjectFile xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" timePrecisionMode="nanosecond" schemaVersion="7.8.0.1">
  <ProjectInformation>
    <Author />
    <Source />
    <FreeFlyerVersion>7.8.1.50021</FreeFlyerVersion>
    <RevisionNumber />
    <Title />
    <Subject />
    <Category />
    <Keywords />
    <Comments />
    <Notes />
  </ProjectInformation>
  <ProjectPreferences>
    <General>
      <LockProjectFromEditing>false</LockProjectFromEditing>
    </General>
    <OnOpen>
      <ShowControlSequence>true</ShowControlSequence>
      <ShowEmptyEnvironment>false</ShowEmptyEnvironment>
      <ShowNotes>false</ShowNotes>
      <ShowHome>false</ShowHome>
      <ShowOutput>false</ShowOutput>
      <CreateBackup>false</CreateBackup>
      <BackupLocation></BackupLocation>
    </OnOpen>
    <OnRun>
      <SaveMissionPlan>false</SaveMissionPlan>
      <HideWarningMessages>false</HideWarningMessages>
    </OnRun>
  </ProjectPreferences>
  <ProjectDataFiles>
    <EarthOrientationFile useDefault="true"></EarthOrientationFile>
    <ElectronDensityCoefficientFile useDefault="true"></ElectronDensityCoefficientFile>
    <GeopotentialFile useDefault="true"></GeopotentialFile>
    <HarrisPriesterDragFile useDefault="true"></HarrisPriesterDragFile>
    <JacchiaAtmosphereModelFile useDefault="true"></JacchiaAtmosphereModelFile>
    <LeapSecondFile useDefault="true"></LeapSecondFile>
    <MagneticFieldFile useDefault="true"></MagneticFieldFile>
    <PlanetaryFile useDefault="true"></PlanetaryFile>
    <StationGeodeticsFile useDefault="true"></StationGeodeticsFile>
    <SolidTideFile useDefault="true"></SolidTideFile>
    <DSTFile useDefault="true"></DSTFile>
    <StarFieldFile useDefault="true"></StarFieldFile>
  </ProjectDataFiles>
  <ProjectObjects>
    <Object>
      <SolarSystem name="FF_SolarSystem" isConstant="false" isGlobal="true">
        <Name>FF_SolarSystem</Name>
        <ComputePolarMotion>true</ComputePolarMotion>
        <ApplyUT1Correction>true</ApplyUT1Correction>
        <COUpdateInterval units="s" displayed_units="s">0</COUpdateInterval>
        <NPUpdateInterval units="s" displayed_units="s">1800</NPUpdateInterval>
        <IonosphereOptions>
          <IonosphereOptions name="FF_SolarSystem_|ionoOptions|" isConstant="false" isGlobal="true">
            <Name>FF_SolarSystem_|ionoOptions|</Name>
            <MaximumHeight units="km" displayed_units="km">1000</MaximumHeight>
            <MinimumHeight units="km" displayed_units="km">80</MinimumHeight>
            <IntegrationStepSize units="km" displayed_units="km">25</IntegrationStepSize>
            <ScaleFactor units="" displayed_units="">1</ScaleFactor>
            <Model>0</Model>
            <metadata dim="0" />
          </IonosphereOptions>
        </IonosphereOptions>
        <NoradKeplerEqTolerance units="" displayed_units="">1e-12</NoradKeplerEqTolerance>
        <metadata dim="0" />
      </SolarSystem>
    </Object>
    <Object>
      <ConsoleWindow name="Console" isConstant="false" isGlobal="true">
        <Name>Console</Name>
        <WindowTitle>Console</WindowTitle>
        <WordWrap>false</WordWrap>
        <CurrentTextColor>12245189</CurrentTextColor>
        <BackColor>2039583</BackColor>
        <Dimension units="" displayed_units="">40</Dimension>
        <DockMode>3</DockMode>
        <CurrentFontType>0</CurrentFontType>
        <UseStdOut>false</UseStdOut>
        <ShowOnRun>true</ShowOnRun>
        <metadata dim="0" />
      </ConsoleWindow>
    </Object>
    <Object>
      <ConsoleWindow name="ConsoleSolver" isConstant="false" isGlobal="true">
        <Name>ConsoleSolver</Name>
        <WindowTitle>Console</WindowTitle>
        <WordWrap>false</WordWrap>
        <CurrentTextColor>12245189</CurrentTextColor>
        <BackColor>2039583</BackColor>
        <Dimension units="" displayed_units="">90</Dimension>
        <DockMode>4</DockMode>
        <CurrentFontType>0</CurrentFontType>
        <UseStdOut>false</UseStdOut>
        <ShowOnRun>true</ShowOnRun>
        <metadata dim="0" />
      </ConsoleWindow>
    </Object>
  </ProjectObjects>
  <ProjectMissionSequence>
    <ProjectExternals>
      <ProjectExternal included="true" autosave="true" contentType="FreeFlyerScript">.\Procedures\Common.FFProcedure</ProjectExternal>
    </ProjectExternals>
    <ProjectCommands>
      <FreeForm enabled="true">
        <Label>FreeForm</Label>
        <Bookmarks />
        <Breakpoints />
        <FreeFormScript><![CDATA[
Variable strategyRequest;

Array blueCartState(6);
Array red1CartState(6);
Array red2CartState(6);
Array red3CartState(6);
Array initialCartState(6);
Array desiredKepState(6);
Variable desiredLongitude;
Variable initialEpochDays;
Variable computationDelayHours;
Array interBurnTimeBoundsDays(2);
Variable slewAngle;

Array dv1(3);
Array dv2(3);
Variable interBurnTimeDays;

TimeSpan interBurnTime;
Variable epochDays;

Formation red;
Formation blue;
Call InitializeFormations(red, blue);
blue[0].Propagator.StepSize = TimeSpan.FromSeconds(800);

(blue[0].Propagator AsType Integrator).FixedStep = 0;
(red[0].Propagator AsType Integrator).FixedStep = 0;
(red[1].Propagator AsType Integrator).FixedStep = 0;
(red[2].Propagator AsType Integrator).FixedStep = 0;

Global List<QueuedAction> actions;

Global Array lastStableBlueGeoOrbit(6);

Global Variable lastBlueRadius;
Global Variable lastBlueLongitude;

Global Socket connection;
connection.SocketType = "server";
connection.PortNumber = redStrategyServerPort;
connection.SocketTimeout = -1;]]></FreeFormScript>
      </FreeForm>
      <FreeForm enabled="true">
        <Label>FreeForm</Label>
        <Bookmarks />
        <Breakpoints />
        <FreeFormScript><![CDATA[
Define Procedure ComputeStationKeepingManeuver(Optimizer opt, Spacecraft sc, Variable longitude);
	TimeSpan initialEpoch;
	opt.Reset(1);
	opt.AddStateVariableBlock(3, "dv", 0.0001, -0.001, 0.001, 1, 1e-6);
	
	opt.SaveObjectToProcess(sc);
	
	opt.MaximumNominalEvaluationCount = 100;
	opt.LoadEngine();
	While (opt.IsRunning() and opt.GetBestObjectiveFunctionValue() < 24*4);
		opt.UpdateStateVariables();
		opt.RestoreObjectsInProcess();
		
		burn.BurnDirection = opt.GetStateVariableValues();
		
		sc.Maneuver(burn);
		
		initialEpoch = sc.Epoch;
		While (abs(sc.Longitude - longitude) < 0.02);
			sc.Step(TimeSpan.FromSeconds(1000));
		End;
		
		opt.Maximize((sc.Epoch - initialEpoch).ToHours());
		
		If (opt.OptimizationPhase == 1);
			Report opt.NominalEvaluationCount, "   ",
			opt.ObjectiveFunctionValue, "   ",
			opt.MaximumInfeasibility, "   ",
			opt.MaximumInfeasibilitySource to ConsoleSolver;
		End;
	End;
	
	Report opt.ReturnString to ConsoleSolver;
	opt.RestoreObjectsInProcess();
EndProcedure;

Define Procedure TargetNewOrbit(
		Spacecraft sc,
		Array kepState,
		Variable longitude,
		Array timeBoundsDays,
		Array dv1,
		Array dv2,
		TimeSpan interBurnTime);
	Variable totalDV;
	TimeSpan futureEpoch;
	Variable addLongitudeConstraint;
	Optimizer opt;
	
	opt.Reset(1);
	opt.AddStateVariableBlock(3, "dv1", 0.001, -0.01, 0.01);
	opt.AddStateVariableBlock(3, "dv2", 0.001, -0.01, 0.01);
	opt.AddStateVariable("days", timeBoundsDays.Mean, timeBoundsDays[0], timeBoundsDays[1]);
	opt.AddConstraint("A",    kepState[0], kepState[0], 100);
	opt.AddConstraint("E",    kepState[1], kepState[1]);
	opt.AddConstraint("I",    kepState[2], kepState[2], 100, 360);
	
	addLongitudeConstraint = longitude != -999;
	If (addLongitudeConstraint);
		opt.AddConstraint("lon",   longitude, longitude, 100, 360);
	Else;
		opt.AddConstraint("RAAN", kepState[3], kepState[3], 100, 360);
		opt.AddConstraint("W",    kepState[4], kepState[4], 100, 360);
	End;
	
	opt.SaveObjectToProcess(sc);
	opt.MaximumNominalEvaluationCount = 1000;
	
	IpoptOptions ipopt;
	ipopt.Tolerance = 1e-4;
	
	opt.LoadEngine(ipopt);
	While (opt.IsRunning());
		opt.UpdateStateVariables();
		opt.RestoreObjectsInProcess();
		
		burn.BurnDirection = opt.GetStateVariableValues[0:2];
		totalDV = burn.BurnDirection.Norm;
		sc.Maneuver(burn);
		
		futureEpoch = sc.Epoch + TimeSpan.FromDays(opt.GetStateVariableValue("days"));
		WhileStepping sc to (sc.Epoch == futureEpoch);
		End;
		
		burn.BurnDirection = opt.GetStateVariableValues[3:5];
		totalDV += burn.BurnDirection.Norm;
		sc.Maneuver(burn);
		
		opt.SetConstraintValue("A", sc.A);
		opt.SetConstraintValue("E", sc.E);
		opt.SetConstraintValue("I", sc.I);

		If (addLongitudeConstraint);
			opt.SetConstraintValue("lon", sc.Longitude);
		Else;
			opt.SetConstraintValue("RAAN", sc.RAAN);
			opt.SetConstraintValue("W", sc.W);
		End;
								 
		opt.Minimize(totalDV);
		
//		If (opt.OptimizationPhase == 1);
//			Report opt.NominalEvaluationCount, "   ",
//			opt.ObjectiveFunctionValue, "   ",
//			opt.MaximumInfeasibility, "   ",
//			opt.MaximumInfeasibilitySource to ConsoleSolver;
//		End;
		
	End;
	
	Report opt.ReturnString to ConsoleSolver;
	opt.RestoreObjectsInProcess();
		
	
	dv1[0] = opt.GetBestStateVariableValue("dv11");
	dv1[1] = opt.GetBestStateVariableValue("dv12");
	dv1[2] = opt.GetBestStateVariableValue("dv13");
	dv2[0] = opt.GetBestStateVariableValue("dv21");
	dv2[1] = opt.GetBestStateVariableValue("dv22");
	dv2[2] = opt.GetBestStateVariableValue("dv23");
	interBurnTime = TimeSpan.FromDays(opt.GetBestStateVariableValue("days"));
	
	If (addLongitudeConstraint);
		burn.BurnDirection = dv1;
		sc.Maneuver(burn);
		
		futureEpoch = sc.Epoch + interBurnTime;
		WhileStepping sc to (sc.Epoch == futureEpoch);
		End;
		
		burn.BurnDirection = dv2;
		sc.Maneuver(burn);
		
		Call ComputeStationKeepingManeuver(opt, sc, longitude);
		dv2 += opt.GetBestStateVariableValues();
	End;
EndProcedure;


Define Procedure ComputeDesiredSlewAngle(Spacecraft red, Spacecraft blue, Variable slewAngle);
	Variable bestAngleFromPayload = 0;
	
	Variable range;
	Variable angle;
	Variable i;
	Variable initialEulerAngle = blue.EulerAngles[0];
	For i = 0 to 360 step 5;
		blue.EulerAngles[0] = i;
		Call ComputeRangeAndAngleFromPayload(blue, red, range, angle);
		If (angle > bestAngleFromPayload);
			slewAngle = i;
			bestAngleFromPayload = angle;
		End;
	End;
	blue.EulerAngles[0] = initialEulerAngle;
EndProcedure;


Define Procedure HasBlueManeuvered(Spacecraft blue, Variable blueHasManeuvered);
	blueHasManeuvered = 0;
	If (abs(blue.Radius - lastBlueRadius) > 5
			or abs(blue.Longitude - lastBlueLongitude) > 0.15);
		blueHasManeuvered = 1;
		lastBlueLongitude = blue.Longitude;
		lastBlueRadius = blue.Radius;
	End;
EndProcedure;


Define Procedure ComputeDisableScriptRed2And3TransitManeuvers(
		Spacecraft red,
		Spacecraft blue,
		TimeSpan incursionEpoch,
		Array dv1,
		Array dv2,
		Array dv3,
		TimeSpan interBurnTime1,
		TimeSpan interBurnTime2);
	TimeSpan arrivalTimeDelta = incursionEpoch - blue.Epoch;
	
	Optimizer opt;
	opt.Reset(1);
	opt.AddStateVariableBlock(3, "dv1", 0.0001, -0.001, 0.001);
	opt.AddStateVariableBlock(3, "dv2", 0.0001, -0.001, 0.001);
	opt.AddStateVariableBlock(3, "dv3", 0.0001, -0.001, 0.001);
	opt.AddStateVariable("interBurnTime1", arrivalTimeDelta.Scaled(0.3).ToDays(), 0.1, arrivalTimeDelta.ToDays());
	opt.AddStateVariable("interBurnTime2", arrivalTimeDelta.Scaled(0.3).ToDays(), 0.1, arrivalTimeDelta.ToDays());
	
	opt.AddConstraint("E",    0, 0.0001);
	opt.AddConstraint("arrivalRadius", 42164 - 70, 42164 + 70);
	opt.AddConstraint("arrivalLonDelta", -0.1, 0.1);
	opt.AddConstraint("coastTime", 0, arrivalTimeDelta.ToDays());

	opt.SaveObjectToProcess(red);
	opt.SaveObjectToProcess(blue);
	opt.MaximumNominalEvaluationCount = 80;

	IpoptOptions ipopt;
	ipopt.Tolerance = 1e-4;
	
	TimeSpan epochToStepTo;
	Variable totalDV;
	
	opt.LoadEngine(ipopt);
	While (opt.IsRunning());
		opt.UpdateStateVariables();
		opt.RestoreObjectsInProcess();
		
		burn.BurnDirection = opt.GetStateVariableValues[0:2];
		totalDV = burn.BurnDirection.Norm;
		red.Maneuver(burn);
		
		interBurnTime1 = TimeSpan.FromDays(opt.GetStateVariableValue("interBurnTime1"));
		epochToStepTo = red.Epoch + interBurnTime1;
		WhileStepping red to (red.Epoch == epochToStepTo);
			blue.StepToEpoch(red.Epoch);
		End;

		burn.BurnDirection = opt.GetStateVariableValues[3:5];
		totalDV += burn.BurnDirection.Norm;
		red.Maneuver(burn);
		
		interBurnTime2 = TimeSpan.FromDays(opt.GetStateVariableValue("interBurnTime2"));
		epochToStepTo = red.Epoch + interBurnTime2;
		WhileStepping red to (red.Epoch == epochToStepTo);
			blue.StepToEpoch(red.Epoch);
		End;

		burn.BurnDirection = opt.GetStateVariableValues[6:8];
		totalDV += burn.BurnDirection.Norm;
		red.Maneuver(burn);
		
		opt.SetConstraintValue("E", red.E);
		
		WhileStepping red to (red.Epoch == incursionEpoch);
			blue.StepToEpoch(red.Epoch);
		End;
		
		opt.SetConstraintValue("coastTime", (interBurnTime1 + interBurnTime2).ToDays());
		opt.SetConstraintValue("arrivalRadius", red.Radius);
		opt.SetConstraintValue("arrivalLonDelta", blue.Longitude - red.Longitude);
							 
		opt.Minimize(totalDV);
		
		If (opt.OptimizationPhase == 1);
			Report opt.NominalEvaluationCount, "   ",
			opt.ObjectiveFunctionValue, "   ",
			opt.MaximumInfeasibility, "   ",
			opt.MaximumInfeasibilitySource to ConsoleSolver;
		End;
	End;
	
	Report opt.ReturnString to ConsoleSolver;
	opt.RestoreObjectsInProcess();
		
	
	dv1[0] = opt.GetBestStateVariableValue("dv11");
	dv1[1] = opt.GetBestStateVariableValue("dv12");
	dv1[2] = opt.GetBestStateVariableValue("dv13");
	dv2[0] = opt.GetBestStateVariableValue("dv21");
	dv2[1] = opt.GetBestStateVariableValue("dv22");
	dv2[2] = opt.GetBestStateVariableValue("dv23");
	dv3[0] = opt.GetBestStateVariableValue("dv31");
	dv3[1] = opt.GetBestStateVariableValue("dv32");
	dv3[2] = opt.GetBestStateVariableValue("dv33");
	interBurnTime1 = TimeSpan.FromDays(opt.GetBestStateVariableValue("interBurnTime1"));
	interBurnTime2 = TimeSpan.FromDays(opt.GetBestStateVariableValue("interBurnTime2"));
EndProcedure;


Define Procedure IsBlueInStableGeoOrbit(Spacecraft blue, Variable blueIsInStableGeoOrbit);
	blueIsInStableGeoOrbit = 0;
	If (abs(blue.Radius - 42164) < 5);
		If (blue.E < 0.001);
			blueIsInStableGeoOrbit = 1;
		End;
	End;
	
EndProcedure;

Define Procedure WillUpdateOccur(Spacecraft blue, Variable updateWillOccur);
	updateWillOccur = 1;
	Variable blueHasManeuvered;
	Call HasBlueManeuvered(blue, blueHasManeuvered);
	If (!blueHasManeuvered);
		updateWillOccur = 0;
		Report "Blue has not maneuvered since last update" to Console;
		ExitProcedure;
	End;
	
	Variable blueIsInStableGeoOrbit;
	Call IsBlueInStableGeoOrbit(blue, blueIsInStableGeoOrbit);
	If (!blueIsInStableGeoOrbit);
		updateWillOccur = 0;
		Report "Blue is not in a stable GEO orbit" to Console;
		ExitProcedure;
	End;
	
	
EndProcedure;


Define Procedure ComputeDisableScriptStrategy(Formation red, Formation blue);
	actions.Clear();
	
	
	TimeSpan incursionEpoch = simStartEpoch + TimeSpan.FromHours(24*4 + 1);
	If (blue[0].Epoch > incursionEpoch);
		// TODO return to nominal
		Report "exit past epoch" to Console;
		ExitProcedure;
	End;
	
	Variable updateWillOccur = 0;
	Call WillUpdateOccur(blue[0], updateWillOccur);
	If (!updateWillOccur);
		Send 0 to connection;
		Report "No update will occur" to Console;
		ExitProcedure;
	End;

	Send 1 to connection;
	
	Array dv1(3);
	Array dv2(3);
	Array dv3(3);
	TimeSpan interBurnTime1;
	TimeSpan interBurnTime2;
	
	Alias lastAction = actions[actions.Count - 1];
	
	Call ComputeDisableScriptRed2And3TransitManeuvers(
	red[1],
	blue[0],
	incursionEpoch,
	dv1, dv2, dv3,
	interBurnTime1, interBurnTime2);
	
	actions.Count += 1;
	lastAction.epoch = red[1].Epoch;
	lastAction.burnRIC = dv1;
	lastAction.additionalAction = additionalAction_none;
	lastAction.isBlue = 0;
	lastAction.formationIndex = 1;
	
	actions.Count += 1;
	lastAction.epoch = red[1].Epoch + interBurnTime1;
	lastAction.burnRIC = dv2;
	lastAction.additionalAction = additionalAction_none;
	lastAction.isBlue = 0;
	lastAction.formationIndex = 1;
	
	actions.Count += 1;
	lastAction.epoch = red[1].Epoch + interBurnTime1 + interBurnTime2;
	lastAction.burnRIC = dv3;
	lastAction.additionalAction = additionalAction_none;
	lastAction.isBlue = 0;
	lastAction.formationIndex = 1;
	
EndProcedure;]]></FreeFormScript>
      </FreeForm>
      <FreeForm enabled="true">
        <Label>FreeForm</Label>
        <Bookmarks />
        <Breakpoints />
        <FreeFormScript><![CDATA[
Variable stepSizeSeconds;
Variable gameMode;
Variable uplinkTimeDays;
TimeSpan epochToStepTo;

Variable i;


While (1);	
	Report "Listening on port ", connection.PortNumber.ToString(), "..." to Console;
	Open connection;
	Console.Clear();
	ConsoleSolver.Clear();
	Report "Connected" to Console;
	
	Receive stepSizeSeconds from connection;
	stepSizeSeconds = 800;
	blue[0].Propagator.StepSize = TimeSpan.FromSeconds(stepSizeSeconds);
	red[0].Propagator.StepSize = TimeSpan.FromSeconds(stepSizeSeconds);
	red[1].Propagator.StepSize = TimeSpan.FromSeconds(stepSizeSeconds);
	red[2].Propagator.StepSize = TimeSpan.FromSeconds(stepSizeSeconds);
	
	Receive gameMode from connection;
	
	// Reset these globals so we get an initial strategy update
	lastBlueRadius = 0;
	lastBlueLongitude = -999;
	
	Try;
		While (1);
			Receive strategyRequest from connection;
			Report "" to Console;
			Report "Recieved request: " to Console;
			
			If (strategyRequest == redStrategyRequest_updateStrategy);
				Report "Update Strategy" to Console;
				
				Receive blueCartState,
						red1CartState,
						red2CartState,
						red3CartState,
						epochDays,
						uplinkTimeDays from connection;
				
				blue[0].Epoch = TimeSpan.FromDays(epochDays);
				red[0].Epoch = TimeSpan.FromDays(epochDays);
				red[1].Epoch = TimeSpan.FromDays(epochDays);
				red[2].Epoch = TimeSpan.FromDays(epochDays);
				
				blue[0].SetCartesianState(blueCartState);
				red[0].SetCartesianState(red1CartState);
				red[1].SetCartesianState(red2CartState);
				red[2].SetCartesianState(red3CartState);
				
				epochToStepTo = blue[0].Epoch + TimeSpan.FromDays(uplinkTimeDays);
				WhileStepping blue[0] to (blue[0].Epoch == epochToStepTo);
					red.StepToEpoch(blue[0].Epoch);
				End;
				
				If (gameMode == gameMode_benignScript);
					// TODO
				ElseIf (gameMode == gameMode_observationScript);
					// TODO
				ElseIf (gameMode == gameMode_disableScript);
					Call ComputeDisableScriptStrategy(red, blue);
				End;
				
				Report "Sending data..." to Console;
				Send actions.Count to connection;
				For i = 0 to actions.Count - 1;
					Send actions[i].epoch.ToDays(),
						 actions[i].burnRIC,
						 actions[i].formationIndex,
						 actions[i].additionalAction to connection;
				End;
				Report "Data transfer complete" to Console;
			End;
		End;
	End;
	
	Close connection;
	Report "" to Console;
	Report "Disconnected" to Console;
	Report "" to Console;
End;]]></FreeFormScript>
      </FreeForm>
    </ProjectCommands>
  </ProjectMissionSequence>
  <ProjectScript><![CDATA[
Variable strategyRequest;

Array blueCartState(6);
Array red1CartState(6);
Array red2CartState(6);
Array red3CartState(6);
Array initialCartState(6);
Array desiredKepState(6);
Variable desiredLongitude;
Variable initialEpochDays;
Variable computationDelayHours;
Array interBurnTimeBoundsDays(2);
Variable slewAngle;

Array dv1(3);
Array dv2(3);
Variable interBurnTimeDays;

TimeSpan interBurnTime;
Variable epochDays;

Formation red;
Formation blue;
Call InitializeFormations(red, blue);
blue[0].Propagator.StepSize = TimeSpan.FromSeconds(800);

(blue[0].Propagator AsType Integrator).FixedStep = 0;
(red[0].Propagator AsType Integrator).FixedStep = 0;
(red[1].Propagator AsType Integrator).FixedStep = 0;
(red[2].Propagator AsType Integrator).FixedStep = 0;

Global List<QueuedAction> actions;

Global Array lastStableBlueGeoOrbit(6);

Global Variable lastBlueRadius;
Global Variable lastBlueLongitude;

Global Socket connection;
connection.SocketType = "server";
connection.PortNumber = redStrategyServerPort;
connection.SocketTimeout = -1;

Define Procedure ComputeStationKeepingManeuver(Optimizer opt, Spacecraft sc, Variable longitude);
	TimeSpan initialEpoch;
	opt.Reset(1);
	opt.AddStateVariableBlock(3, "dv", 0.0001, -0.001, 0.001, 1, 1e-6);
	
	opt.SaveObjectToProcess(sc);
	
	opt.MaximumNominalEvaluationCount = 100;
	opt.LoadEngine();
	While (opt.IsRunning() and opt.GetBestObjectiveFunctionValue() < 24*4);
		opt.UpdateStateVariables();
		opt.RestoreObjectsInProcess();
		
		burn.BurnDirection = opt.GetStateVariableValues();
		
		sc.Maneuver(burn);
		
		initialEpoch = sc.Epoch;
		While (abs(sc.Longitude - longitude) < 0.02);
			sc.Step(TimeSpan.FromSeconds(1000));
		End;
		
		opt.Maximize((sc.Epoch - initialEpoch).ToHours());
		
		If (opt.OptimizationPhase == 1);
			Report opt.NominalEvaluationCount, "   ",
			opt.ObjectiveFunctionValue, "   ",
			opt.MaximumInfeasibility, "   ",
			opt.MaximumInfeasibilitySource to ConsoleSolver;
		End;
	End;
	
	Report opt.ReturnString to ConsoleSolver;
	opt.RestoreObjectsInProcess();
EndProcedure;

Define Procedure TargetNewOrbit(
		Spacecraft sc,
		Array kepState,
		Variable longitude,
		Array timeBoundsDays,
		Array dv1,
		Array dv2,
		TimeSpan interBurnTime);
	Variable totalDV;
	TimeSpan futureEpoch;
	Variable addLongitudeConstraint;
	Optimizer opt;
	
	opt.Reset(1);
	opt.AddStateVariableBlock(3, "dv1", 0.001, -0.01, 0.01);
	opt.AddStateVariableBlock(3, "dv2", 0.001, -0.01, 0.01);
	opt.AddStateVariable("days", timeBoundsDays.Mean, timeBoundsDays[0], timeBoundsDays[1]);
	opt.AddConstraint("A",    kepState[0], kepState[0], 100);
	opt.AddConstraint("E",    kepState[1], kepState[1]);
	opt.AddConstraint("I",    kepState[2], kepState[2], 100, 360);
	
	addLongitudeConstraint = longitude != -999;
	If (addLongitudeConstraint);
		opt.AddConstraint("lon",   longitude, longitude, 100, 360);
	Else;
		opt.AddConstraint("RAAN", kepState[3], kepState[3], 100, 360);
		opt.AddConstraint("W",    kepState[4], kepState[4], 100, 360);
	End;
	
	opt.SaveObjectToProcess(sc);
	opt.MaximumNominalEvaluationCount = 1000;
	
	IpoptOptions ipopt;
	ipopt.Tolerance = 1e-4;
	
	opt.LoadEngine(ipopt);
	While (opt.IsRunning());
		opt.UpdateStateVariables();
		opt.RestoreObjectsInProcess();
		
		burn.BurnDirection = opt.GetStateVariableValues[0:2];
		totalDV = burn.BurnDirection.Norm;
		sc.Maneuver(burn);
		
		futureEpoch = sc.Epoch + TimeSpan.FromDays(opt.GetStateVariableValue("days"));
		WhileStepping sc to (sc.Epoch == futureEpoch);
		End;
		
		burn.BurnDirection = opt.GetStateVariableValues[3:5];
		totalDV += burn.BurnDirection.Norm;
		sc.Maneuver(burn);
		
		opt.SetConstraintValue("A", sc.A);
		opt.SetConstraintValue("E", sc.E);
		opt.SetConstraintValue("I", sc.I);

		If (addLongitudeConstraint);
			opt.SetConstraintValue("lon", sc.Longitude);
		Else;
			opt.SetConstraintValue("RAAN", sc.RAAN);
			opt.SetConstraintValue("W", sc.W);
		End;
								 
		opt.Minimize(totalDV);
		
//		If (opt.OptimizationPhase == 1);
//			Report opt.NominalEvaluationCount, "   ",
//			opt.ObjectiveFunctionValue, "   ",
//			opt.MaximumInfeasibility, "   ",
//			opt.MaximumInfeasibilitySource to ConsoleSolver;
//		End;
		
	End;
	
	Report opt.ReturnString to ConsoleSolver;
	opt.RestoreObjectsInProcess();
		
	
	dv1[0] = opt.GetBestStateVariableValue("dv11");
	dv1[1] = opt.GetBestStateVariableValue("dv12");
	dv1[2] = opt.GetBestStateVariableValue("dv13");
	dv2[0] = opt.GetBestStateVariableValue("dv21");
	dv2[1] = opt.GetBestStateVariableValue("dv22");
	dv2[2] = opt.GetBestStateVariableValue("dv23");
	interBurnTime = TimeSpan.FromDays(opt.GetBestStateVariableValue("days"));
	
	If (addLongitudeConstraint);
		burn.BurnDirection = dv1;
		sc.Maneuver(burn);
		
		futureEpoch = sc.Epoch + interBurnTime;
		WhileStepping sc to (sc.Epoch == futureEpoch);
		End;
		
		burn.BurnDirection = dv2;
		sc.Maneuver(burn);
		
		Call ComputeStationKeepingManeuver(opt, sc, longitude);
		dv2 += opt.GetBestStateVariableValues();
	End;
EndProcedure;


Define Procedure ComputeDesiredSlewAngle(Spacecraft red, Spacecraft blue, Variable slewAngle);
	Variable bestAngleFromPayload = 0;
	
	Variable range;
	Variable angle;
	Variable i;
	Variable initialEulerAngle = blue.EulerAngles[0];
	For i = 0 to 360 step 5;
		blue.EulerAngles[0] = i;
		Call ComputeRangeAndAngleFromPayload(blue, red, range, angle);
		If (angle > bestAngleFromPayload);
			slewAngle = i;
			bestAngleFromPayload = angle;
		End;
	End;
	blue.EulerAngles[0] = initialEulerAngle;
EndProcedure;


Define Procedure HasBlueManeuvered(Spacecraft blue, Variable blueHasManeuvered);
	blueHasManeuvered = 0;
	If (abs(blue.Radius - lastBlueRadius) > 5
			or abs(blue.Longitude - lastBlueLongitude) > 0.15);
		blueHasManeuvered = 1;
		lastBlueLongitude = blue.Longitude;
		lastBlueRadius = blue.Radius;
	End;
EndProcedure;


Define Procedure ComputeDisableScriptRed2And3TransitManeuvers(
		Spacecraft red,
		Spacecraft blue,
		TimeSpan incursionEpoch,
		Array dv1,
		Array dv2,
		Array dv3,
		TimeSpan interBurnTime1,
		TimeSpan interBurnTime2);
	TimeSpan arrivalTimeDelta = incursionEpoch - blue.Epoch;
	
	Optimizer opt;
	opt.Reset(1);
	opt.AddStateVariableBlock(3, "dv1", 0.0001, -0.001, 0.001);
	opt.AddStateVariableBlock(3, "dv2", 0.0001, -0.001, 0.001);
	opt.AddStateVariableBlock(3, "dv3", 0.0001, -0.001, 0.001);
	opt.AddStateVariable("interBurnTime1", arrivalTimeDelta.Scaled(0.3).ToDays(), 0.1, arrivalTimeDelta.ToDays());
	opt.AddStateVariable("interBurnTime2", arrivalTimeDelta.Scaled(0.3).ToDays(), 0.1, arrivalTimeDelta.ToDays());
	
	opt.AddConstraint("E",    0, 0.0001);
	opt.AddConstraint("arrivalRadius", 42164 - 70, 42164 + 70);
	opt.AddConstraint("arrivalLonDelta", -0.1, 0.1);
	opt.AddConstraint("coastTime", 0, arrivalTimeDelta.ToDays());

	opt.SaveObjectToProcess(red);
	opt.SaveObjectToProcess(blue);
	opt.MaximumNominalEvaluationCount = 80;

	IpoptOptions ipopt;
	ipopt.Tolerance = 1e-4;
	
	TimeSpan epochToStepTo;
	Variable totalDV;
	
	opt.LoadEngine(ipopt);
	While (opt.IsRunning());
		opt.UpdateStateVariables();
		opt.RestoreObjectsInProcess();
		
		burn.BurnDirection = opt.GetStateVariableValues[0:2];
		totalDV = burn.BurnDirection.Norm;
		red.Maneuver(burn);
		
		interBurnTime1 = TimeSpan.FromDays(opt.GetStateVariableValue("interBurnTime1"));
		epochToStepTo = red.Epoch + interBurnTime1;
		WhileStepping red to (red.Epoch == epochToStepTo);
			blue.StepToEpoch(red.Epoch);
		End;

		burn.BurnDirection = opt.GetStateVariableValues[3:5];
		totalDV += burn.BurnDirection.Norm;
		red.Maneuver(burn);
		
		interBurnTime2 = TimeSpan.FromDays(opt.GetStateVariableValue("interBurnTime2"));
		epochToStepTo = red.Epoch + interBurnTime2;
		WhileStepping red to (red.Epoch == epochToStepTo);
			blue.StepToEpoch(red.Epoch);
		End;

		burn.BurnDirection = opt.GetStateVariableValues[6:8];
		totalDV += burn.BurnDirection.Norm;
		red.Maneuver(burn);
		
		opt.SetConstraintValue("E", red.E);
		
		WhileStepping red to (red.Epoch == incursionEpoch);
			blue.StepToEpoch(red.Epoch);
		End;
		
		opt.SetConstraintValue("coastTime", (interBurnTime1 + interBurnTime2).ToDays());
		opt.SetConstraintValue("arrivalRadius", red.Radius);
		opt.SetConstraintValue("arrivalLonDelta", blue.Longitude - red.Longitude);
							 
		opt.Minimize(totalDV);
		
		If (opt.OptimizationPhase == 1);
			Report opt.NominalEvaluationCount, "   ",
			opt.ObjectiveFunctionValue, "   ",
			opt.MaximumInfeasibility, "   ",
			opt.MaximumInfeasibilitySource to ConsoleSolver;
		End;
	End;
	
	Report opt.ReturnString to ConsoleSolver;
	opt.RestoreObjectsInProcess();
		
	
	dv1[0] = opt.GetBestStateVariableValue("dv11");
	dv1[1] = opt.GetBestStateVariableValue("dv12");
	dv1[2] = opt.GetBestStateVariableValue("dv13");
	dv2[0] = opt.GetBestStateVariableValue("dv21");
	dv2[1] = opt.GetBestStateVariableValue("dv22");
	dv2[2] = opt.GetBestStateVariableValue("dv23");
	dv3[0] = opt.GetBestStateVariableValue("dv31");
	dv3[1] = opt.GetBestStateVariableValue("dv32");
	dv3[2] = opt.GetBestStateVariableValue("dv33");
	interBurnTime1 = TimeSpan.FromDays(opt.GetBestStateVariableValue("interBurnTime1"));
	interBurnTime2 = TimeSpan.FromDays(opt.GetBestStateVariableValue("interBurnTime2"));
EndProcedure;


Define Procedure IsBlueInStableGeoOrbit(Spacecraft blue, Variable blueIsInStableGeoOrbit);
	blueIsInStableGeoOrbit = 0;
	If (abs(blue.Radius - 42164) < 5);
		If (blue.E < 0.001);
			blueIsInStableGeoOrbit = 1;
		End;
	End;
	
EndProcedure;

Define Procedure WillUpdateOccur(Spacecraft blue, Variable updateWillOccur);
	updateWillOccur = 1;
	Variable blueHasManeuvered;
	Call HasBlueManeuvered(blue, blueHasManeuvered);
	If (!blueHasManeuvered);
		updateWillOccur = 0;
		Report "Blue has not maneuvered since last update" to Console;
		ExitProcedure;
	End;
	
	Variable blueIsInStableGeoOrbit;
	Call IsBlueInStableGeoOrbit(blue, blueIsInStableGeoOrbit);
	If (!blueIsInStableGeoOrbit);
		updateWillOccur = 0;
		Report "Blue is not in a stable GEO orbit" to Console;
		ExitProcedure;
	End;
	
	
EndProcedure;


Define Procedure ComputeDisableScriptStrategy(Formation red, Formation blue);
	actions.Clear();
	
	
	TimeSpan incursionEpoch = simStartEpoch + TimeSpan.FromHours(24*4 + 1);
	If (blue[0].Epoch > incursionEpoch);
		// TODO return to nominal
		Report "exit past epoch" to Console;
		ExitProcedure;
	End;
	
	Variable updateWillOccur = 0;
	Call WillUpdateOccur(blue[0], updateWillOccur);
	If (!updateWillOccur);
		Send 0 to connection;
		Report "No update will occur" to Console;
		ExitProcedure;
	End;

	Send 1 to connection;
	
	Array dv1(3);
	Array dv2(3);
	Array dv3(3);
	TimeSpan interBurnTime1;
	TimeSpan interBurnTime2;
	
	Alias lastAction = actions[actions.Count - 1];
	
	Call ComputeDisableScriptRed2And3TransitManeuvers(
	red[1],
	blue[0],
	incursionEpoch,
	dv1, dv2, dv3,
	interBurnTime1, interBurnTime2);
	
	actions.Count += 1;
	lastAction.epoch = red[1].Epoch;
	lastAction.burnRIC = dv1;
	lastAction.additionalAction = additionalAction_none;
	lastAction.isBlue = 0;
	lastAction.formationIndex = 1;
	
	actions.Count += 1;
	lastAction.epoch = red[1].Epoch + interBurnTime1;
	lastAction.burnRIC = dv2;
	lastAction.additionalAction = additionalAction_none;
	lastAction.isBlue = 0;
	lastAction.formationIndex = 1;
	
	actions.Count += 1;
	lastAction.epoch = red[1].Epoch + interBurnTime1 + interBurnTime2;
	lastAction.burnRIC = dv3;
	lastAction.additionalAction = additionalAction_none;
	lastAction.isBlue = 0;
	lastAction.formationIndex = 1;
	
EndProcedure;

Variable stepSizeSeconds;
Variable gameMode;
Variable uplinkTimeDays;
TimeSpan epochToStepTo;

Variable i;


While (1);	
	Report "Listening on port ", connection.PortNumber.ToString(), "..." to Console;
	Open connection;
	Console.Clear();
	ConsoleSolver.Clear();
	Report "Connected" to Console;
	
	Receive stepSizeSeconds from connection;
	stepSizeSeconds = 800;
	blue[0].Propagator.StepSize = TimeSpan.FromSeconds(stepSizeSeconds);
	red[0].Propagator.StepSize = TimeSpan.FromSeconds(stepSizeSeconds);
	red[1].Propagator.StepSize = TimeSpan.FromSeconds(stepSizeSeconds);
	red[2].Propagator.StepSize = TimeSpan.FromSeconds(stepSizeSeconds);
	
	Receive gameMode from connection;
	
	// Reset these globals so we get an initial strategy update
	lastBlueRadius = 0;
	lastBlueLongitude = -999;
	
	Try;
		While (1);
			Receive strategyRequest from connection;
			Report "" to Console;
			Report "Recieved request: " to Console;
			
			If (strategyRequest == redStrategyRequest_updateStrategy);
				Report "Update Strategy" to Console;
				
				Receive blueCartState,
						red1CartState,
						red2CartState,
						red3CartState,
						epochDays,
						uplinkTimeDays from connection;
				
				blue[0].Epoch = TimeSpan.FromDays(epochDays);
				red[0].Epoch = TimeSpan.FromDays(epochDays);
				red[1].Epoch = TimeSpan.FromDays(epochDays);
				red[2].Epoch = TimeSpan.FromDays(epochDays);
				
				blue[0].SetCartesianState(blueCartState);
				red[0].SetCartesianState(red1CartState);
				red[1].SetCartesianState(red2CartState);
				red[2].SetCartesianState(red3CartState);
				
				epochToStepTo = blue[0].Epoch + TimeSpan.FromDays(uplinkTimeDays);
				WhileStepping blue[0] to (blue[0].Epoch == epochToStepTo);
					red.StepToEpoch(blue[0].Epoch);
				End;
				
				If (gameMode == gameMode_benignScript);
					// TODO
				ElseIf (gameMode == gameMode_observationScript);
					// TODO
				ElseIf (gameMode == gameMode_disableScript);
					Call ComputeDisableScriptStrategy(red, blue);
				End;
				
				Report "Sending data..." to Console;
				Send actions.Count to connection;
				For i = 0 to actions.Count - 1;
					Send actions[i].epoch.ToDays(),
						 actions[i].burnRIC,
						 actions[i].formationIndex,
						 actions[i].additionalAction to connection;
				End;
				Report "Data transfer complete" to Console;
			End;
		End;
	End;
	
	Close connection;
	Report "" to Console;
	Report "Disconnected" to Console;
	Report "" to Console;
End;]]></ProjectScript>
  <ProjectNotes></ProjectNotes>
</FreeFlyerProjectFile>